// Code generated by girgen. DO NOT EDIT.

package flatpak

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <flatpak.h>
// #include <glib-object.h>
import "C"

// glib.Type values for flatpak-bundle-ref.go.
var GTypeBundleRef = externglib.Type(C.flatpak_bundle_ref_get_type())

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeBundleRef, F: marshalBundleRef},
	})
}

// BundleRefOverrider contains methods that are overridable.
type BundleRefOverrider interface {
}

type BundleRef struct {
	_ [0]func() // equal guard
	Ref
}

var (
	_ externglib.Objector = (*BundleRef)(nil)
)

func classInitBundleReffer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapBundleRef(obj *externglib.Object) *BundleRef {
	return &BundleRef{
		Ref: Ref{
			Object: obj,
		},
	}
}

func marshalBundleRef(p uintptr) (interface{}, error) {
	return wrapBundleRef(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewBundleRef creates a new bundle ref for the given file.
//
// The function takes the following parameters:
//
//    - file: #GFile.
//
// The function returns the following values:
//
//    - bundleRef: new bundle ref.
//
func NewBundleRef(file gio.Filer) (*BundleRef, error) {
	var _arg1 *C.GFile            // out
	var _cret *C.FlatpakBundleRef // in
	var _cerr *C.GError           // in

	_arg1 = (*C.GFile)(unsafe.Pointer(externglib.InternObject(file).Native()))

	_cret = C.flatpak_bundle_ref_new(_arg1, &_cerr)
	runtime.KeepAlive(file)

	var _bundleRef *BundleRef // out
	var _goerr error          // out

	_bundleRef = wrapBundleRef(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bundleRef, _goerr
}

// Appstream: get the compressed appstream for the app/runtime.
//
// The function returns the following values:
//
//    - bytes with the appstream contents, or NULL.
//
func (self *BundleRef) Appstream() *glib.Bytes {
	var _arg0 *C.FlatpakBundleRef // out
	var _cret *C.GBytes           // in

	_arg0 = (*C.FlatpakBundleRef)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_bundle_ref_get_appstream(_arg0)
	runtime.KeepAlive(self)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// File: get the file this bundle is stored in.
//
// The function returns the following values:
//
//    - file: #GFile.
//
func (self *BundleRef) File() *gio.File {
	var _arg0 *C.FlatpakBundleRef // out
	var _cret *C.GFile            // in

	_arg0 = (*C.FlatpakBundleRef)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_bundle_ref_get_file(_arg0)
	runtime.KeepAlive(self)

	var _file *gio.File // out

	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_file = &gio.File{
			Object: obj,
		}
	}

	return _file
}

// Icon: get the icon png data for the app/runtime.
//
// The function takes the following parameters:
//
//    - size: 64 or 128.
//
// The function returns the following values:
//
//    - bytes with png contents.
//
func (self *BundleRef) Icon(size int) *glib.Bytes {
	var _arg0 *C.FlatpakBundleRef // out
	var _arg1 C.int               // out
	var _cret *C.GBytes           // in

	_arg0 = (*C.FlatpakBundleRef)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.int(size)

	_cret = C.flatpak_bundle_ref_get_icon(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(size)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// InstalledSize returns the installed size for the bundle.
//
// The function returns the following values:
//
//    - guint64: installed size.
//
func (self *BundleRef) InstalledSize() uint64 {
	var _arg0 *C.FlatpakBundleRef // out
	var _cret C.guint64           // in

	_arg0 = (*C.FlatpakBundleRef)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_bundle_ref_get_installed_size(_arg0)
	runtime.KeepAlive(self)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Metadata: get the metadata for the app/runtime.
//
// The function returns the following values:
//
//    - bytes with the metadata contents, or NULL.
//
func (self *BundleRef) Metadata() *glib.Bytes {
	var _arg0 *C.FlatpakBundleRef // out
	var _cret *C.GBytes           // in

	_arg0 = (*C.FlatpakBundleRef)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_bundle_ref_get_metadata(_arg0)
	runtime.KeepAlive(self)

	var _bytes *glib.Bytes // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)

	return _bytes
}

// Origin: get the origin url stored in the bundle.
//
// The function returns the following values:
//
//    - utf8: url string, or NULL.
//
func (self *BundleRef) Origin() string {
	var _arg0 *C.FlatpakBundleRef // out
	var _cret *C.char             // in

	_arg0 = (*C.FlatpakBundleRef)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_bundle_ref_get_origin(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// RuntimeRepoURL: get the runtime flatpakrepo url stored in the bundle (if
// any).
//
// The function returns the following values:
//
//    - utf8: url string, or NULL.
//
func (self *BundleRef) RuntimeRepoURL() string {
	var _arg0 *C.FlatpakBundleRef // out
	var _cret *C.char             // in

	_arg0 = (*C.FlatpakBundleRef)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_bundle_ref_get_runtime_repo_url(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}
