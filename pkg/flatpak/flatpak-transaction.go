// Code generated by girgen. DO NOT EDIT.

package flatpak

import (
	"context"
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <flatpak.h>
// #include <glib-object.h>
// extern gboolean _gotk4_flatpak1_TransactionClass_add_new_remote(FlatpakTransaction*, FlatpakTransactionRemoteReason, char*, char*, char*);
// extern gboolean _gotk4_flatpak1_TransactionClass_basic_auth_start(FlatpakTransaction*, char*, char*, GVariant*, guint);
// extern gboolean _gotk4_flatpak1_TransactionClass_operation_error(FlatpakTransaction*, FlatpakTransactionOperation*, GError*, FlatpakTransactionErrorDetails);
// extern gboolean _gotk4_flatpak1_TransactionClass_ready(FlatpakTransaction*);
// extern gboolean _gotk4_flatpak1_TransactionClass_ready_pre_auth(FlatpakTransaction*);
// extern gboolean _gotk4_flatpak1_TransactionClass_run(FlatpakTransaction*, GCancellable*, GError**);
// extern gboolean _gotk4_flatpak1_TransactionClass_webflow_start(FlatpakTransaction*, char*, char*, GVariant*, guint);
// extern gboolean _gotk4_flatpak1_Transaction_ConnectAddNewRemote(gpointer, gint, gchar*, gchar*, gchar*, guintptr);
// extern gboolean _gotk4_flatpak1_Transaction_ConnectBasicAuthStart(gpointer, gchar*, gchar*, GVariant*, gint, guintptr);
// extern gboolean _gotk4_flatpak1_Transaction_ConnectOperationError(gpointer, FlatpakTransactionOperation*, GError*, gint, guintptr);
// extern gboolean _gotk4_flatpak1_Transaction_ConnectReady(gpointer, guintptr);
// extern gboolean _gotk4_flatpak1_Transaction_ConnectReadyPreAuth(gpointer, guintptr);
// extern gboolean _gotk4_flatpak1_Transaction_ConnectWebflowStart(gpointer, gchar*, gchar*, GVariant*, gint, guintptr);
// extern void _gotk4_flatpak1_TransactionClass_end_of_lifed(FlatpakTransaction*, char*, char*, char*);
// extern void _gotk4_flatpak1_TransactionClass_install_authenticator(FlatpakTransaction*, char*, char*);
// extern void _gotk4_flatpak1_TransactionClass_new_operation(FlatpakTransaction*, FlatpakTransactionOperation*, FlatpakTransactionProgress*);
// extern void _gotk4_flatpak1_TransactionClass_operation_done(FlatpakTransaction*, FlatpakTransactionOperation*, char*, FlatpakTransactionResult);
// extern void _gotk4_flatpak1_TransactionClass_webflow_done(FlatpakTransaction*, GVariant*, guint);
// extern void _gotk4_flatpak1_TransactionProgress_ConnectChanged(gpointer, guintptr);
// extern void _gotk4_flatpak1_Transaction_ConnectEndOfLifed(gpointer, gchar*, gchar*, gchar*, guintptr);
// extern void _gotk4_flatpak1_Transaction_ConnectInstallAuthenticator(gpointer, gchar*, gchar*, guintptr);
// extern void _gotk4_flatpak1_Transaction_ConnectNewOperation(gpointer, FlatpakTransactionOperation*, FlatpakTransactionProgress*, guintptr);
// extern void _gotk4_flatpak1_Transaction_ConnectOperationDone(gpointer, FlatpakTransactionOperation*, gchar*, gint, guintptr);
// extern void _gotk4_flatpak1_Transaction_ConnectWebflowDone(gpointer, GVariant*, gint, guintptr);
import "C"

// glib.Type values for flatpak-transaction.go.
var (
	GTypeTransactionOperationType = externglib.Type(C.flatpak_transaction_operation_type_get_type())
	GTypeTransactionRemoteReason  = externglib.Type(C.flatpak_transaction_remote_reason_get_type())
	GTypeTransactionErrorDetails  = externglib.Type(C.flatpak_transaction_error_details_get_type())
	GTypeTransactionResult        = externglib.Type(C.flatpak_transaction_result_get_type())
	GTypeTransaction              = externglib.Type(C.flatpak_transaction_get_type())
	GTypeTransactionOperation     = externglib.Type(C.flatpak_transaction_operation_get_type())
	GTypeTransactionProgress      = externglib.Type(C.flatpak_transaction_progress_get_type())
)

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeTransactionOperationType, F: marshalTransactionOperationType},
		{T: GTypeTransactionRemoteReason, F: marshalTransactionRemoteReason},
		{T: GTypeTransactionErrorDetails, F: marshalTransactionErrorDetails},
		{T: GTypeTransactionResult, F: marshalTransactionResult},
		{T: GTypeTransaction, F: marshalTransaction},
		{T: GTypeTransactionOperation, F: marshalTransactionOperation},
		{T: GTypeTransactionProgress, F: marshalTransactionProgress},
	})
}

// TransactionOperationType: type of a TransactionOperation.
type TransactionOperationType C.gint

const (
	// TransactionOperationInstall: install a ref from a remote.
	TransactionOperationInstall TransactionOperationType = iota
	// TransactionOperationUpdate: update an installed ref.
	TransactionOperationUpdate
	// TransactionOperationInstallBundle: install a bundle from a file.
	TransactionOperationInstallBundle
	// TransactionOperationUninstall: uninstall a ref.
	TransactionOperationUninstall
	// TransactionOperationLastType: (currently) last operation type.
	TransactionOperationLastType
)

func marshalTransactionOperationType(p uintptr) (interface{}, error) {
	return TransactionOperationType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TransactionOperationType.
func (t TransactionOperationType) String() string {
	switch t {
	case TransactionOperationInstall:
		return "Install"
	case TransactionOperationUpdate:
		return "Update"
	case TransactionOperationInstallBundle:
		return "InstallBundle"
	case TransactionOperationUninstall:
		return "Uninstall"
	case TransactionOperationLastType:
		return "LastType"
	default:
		return fmt.Sprintf("TransactionOperationType(%d)", t)
	}
}

// TransactionOperationTypeToString converts the operation type to a string.
//
// The function takes the following parameters:
//
//    - kind: TransactionOperationType.
//
// The function returns the following values:
//
//    - utf8: string representing kind.
//
func TransactionOperationTypeToString(kind TransactionOperationType) string {
	var _arg1 C.FlatpakTransactionOperationType // out
	var _cret *C.char                           // in

	_arg1 = C.FlatpakTransactionOperationType(kind)

	_cret = C.flatpak_transaction_operation_type_to_string(_arg1)
	runtime.KeepAlive(kind)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// TransactionRemoteReason: reason for Transaction::add-new-remote.
type TransactionRemoteReason C.gint

const (
	// TransactionRemoteGenericRepo: remote specified in the flatpakref has
	// other apps too.
	TransactionRemoteGenericRepo TransactionRemoteReason = iota
	// TransactionRemoteRuntimeDeps: remote has runtimes needed for the app.
	TransactionRemoteRuntimeDeps
)

func marshalTransactionRemoteReason(p uintptr) (interface{}, error) {
	return TransactionRemoteReason(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for TransactionRemoteReason.
func (t TransactionRemoteReason) String() string {
	switch t {
	case TransactionRemoteGenericRepo:
		return "GenericRepo"
	case TransactionRemoteRuntimeDeps:
		return "RuntimeDeps"
	default:
		return fmt.Sprintf("TransactionRemoteReason(%d)", t)
	}
}

// TransactionErrorDetails details for Transaction::operation-error.
type TransactionErrorDetails C.guint

const (
	// TransactionErrorDetailsNonFatal: operation failure was not fatal.
	TransactionErrorDetailsNonFatal TransactionErrorDetails = 0b1
)

func marshalTransactionErrorDetails(p uintptr) (interface{}, error) {
	return TransactionErrorDetails(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TransactionErrorDetails.
func (t TransactionErrorDetails) String() string {
	if t == 0 {
		return "TransactionErrorDetails(0)"
	}

	var builder strings.Builder
	builder.Grow(31)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TransactionErrorDetailsNonFatal:
			builder.WriteString("Fatal|")
		default:
			builder.WriteString(fmt.Sprintf("TransactionErrorDetails(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TransactionErrorDetails) Has(other TransactionErrorDetails) bool {
	return (t & other) == other
}

// TransactionResult details for Transaction::operation-done.
type TransactionResult C.guint

const (
	// TransactionResultNoChange: update caused no changes.
	TransactionResultNoChange TransactionResult = 0b1
)

func marshalTransactionResult(p uintptr) (interface{}, error) {
	return TransactionResult(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for TransactionResult.
func (t TransactionResult) String() string {
	if t == 0 {
		return "TransactionResult(0)"
	}

	var builder strings.Builder
	builder.Grow(25)

	for t != 0 {
		next := t & (t - 1)
		bit := t - next

		switch bit {
		case TransactionResultNoChange:
			builder.WriteString("Change|")
		default:
			builder.WriteString(fmt.Sprintf("TransactionResult(0b%b)|", bit))
		}

		t = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if t contains other.
func (t TransactionResult) Has(other TransactionResult) bool {
	return (t & other) == other
}

// TransactionOverrider contains methods that are overridable.
type TransactionOverrider interface {
	// The function takes the following parameters:
	//
	//    - reason
	//    - fromId
	//    - remoteName
	//    - url
	//
	// The function returns the following values:
	//
	AddNewRemote(reason TransactionRemoteReason, fromId, remoteName, url string) bool
	// The function takes the following parameters:
	//
	//    - remote
	//    - realm
	//    - options
	//    - id
	//
	// The function returns the following values:
	//
	BasicAuthStart(remote, realm string, options *glib.Variant, id uint) bool
	// The function takes the following parameters:
	//
	//    - ref
	//    - reason
	//    - rebase
	//
	EndOfLifed(ref, reason, rebase string)
	// The function takes the following parameters:
	//
	//    - remote
	//    - authenticatorRef
	//
	InstallAuthenticator(remote, authenticatorRef string)
	// The function takes the following parameters:
	//
	//    - operation
	//    - progress
	//
	NewOperation(operation *TransactionOperation, progress *TransactionProgress)
	// The function takes the following parameters:
	//
	//    - operation
	//    - commit
	//    - details
	//
	OperationDone(operation *TransactionOperation, commit string, details TransactionResult)
	// The function takes the following parameters:
	//
	//    - operation
	//    - err
	//    - detail
	//
	// The function returns the following values:
	//
	OperationError(operation *TransactionOperation, err error, detail TransactionErrorDetails) bool
	// The function returns the following values:
	//
	Ready() bool
	// The function returns the following values:
	//
	ReadyPreAuth() bool
	// Run executes the transaction.
	//
	// During the course of the execution, various signals will get emitted. The
	// FlatpakTransaction::choose-remote-for-ref and Transaction::add-new-remote
	// signals may get emitted while resolving operations. Transaction::ready is
	// emitted when the transaction has been fully resolved, and
	// Transaction::new-operation and Transaction::operation-done are emitted
	// while the operations are carried out. If an error occurs at any point
	// during the execution, Transaction::operation-error is emitted.
	//
	// Note that this call blocks until the transaction is done.
	//
	// The function takes the following parameters:
	//
	//    - ctx (optional): #GCancellable.
	//
	Run(ctx context.Context) error
	// The function takes the following parameters:
	//
	//    - options
	//    - id
	//
	WebflowDone(options *glib.Variant, id uint)
	// The function takes the following parameters:
	//
	//    - remote
	//    - url
	//    - options
	//    - id
	//
	// The function returns the following values:
	//
	WebflowStart(remote, url string, options *glib.Variant, id uint) bool
}

type Transaction struct {
	_ [0]func() // equal guard
	*externglib.Object

	gio.Initable
}

var (
	_ externglib.Objector = (*Transaction)(nil)
)

func classInitTransactioner(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

	goval := gbox.Get(uintptr(data))
	pclass := (*C.FlatpakTransactionClass)(unsafe.Pointer(gclassPtr))
	// gclass := (*C.GTypeClass)(unsafe.Pointer(gclassPtr))
	// pclass := (*C.FlatpakTransactionClass)(unsafe.Pointer(C.g_type_class_peek_parent(gclass)))

	if _, ok := goval.(interface {
		AddNewRemote(reason TransactionRemoteReason, fromId, remoteName, url string) bool
	}); ok {
		pclass.add_new_remote = (*[0]byte)(C._gotk4_flatpak1_TransactionClass_add_new_remote)
	}

	if _, ok := goval.(interface {
		BasicAuthStart(remote, realm string, options *glib.Variant, id uint) bool
	}); ok {
		pclass.basic_auth_start = (*[0]byte)(C._gotk4_flatpak1_TransactionClass_basic_auth_start)
	}

	if _, ok := goval.(interface {
		EndOfLifed(ref, reason, rebase string)
	}); ok {
		pclass.end_of_lifed = (*[0]byte)(C._gotk4_flatpak1_TransactionClass_end_of_lifed)
	}

	if _, ok := goval.(interface {
		InstallAuthenticator(remote, authenticatorRef string)
	}); ok {
		pclass.install_authenticator = (*[0]byte)(C._gotk4_flatpak1_TransactionClass_install_authenticator)
	}

	if _, ok := goval.(interface {
		NewOperation(operation *TransactionOperation, progress *TransactionProgress)
	}); ok {
		pclass.new_operation = (*[0]byte)(C._gotk4_flatpak1_TransactionClass_new_operation)
	}

	if _, ok := goval.(interface {
		OperationDone(operation *TransactionOperation, commit string, details TransactionResult)
	}); ok {
		pclass.operation_done = (*[0]byte)(C._gotk4_flatpak1_TransactionClass_operation_done)
	}

	if _, ok := goval.(interface {
		OperationError(operation *TransactionOperation, err error, detail TransactionErrorDetails) bool
	}); ok {
		pclass.operation_error = (*[0]byte)(C._gotk4_flatpak1_TransactionClass_operation_error)
	}

	if _, ok := goval.(interface{ Ready() bool }); ok {
		pclass.ready = (*[0]byte)(C._gotk4_flatpak1_TransactionClass_ready)
	}

	if _, ok := goval.(interface{ ReadyPreAuth() bool }); ok {
		pclass.ready_pre_auth = (*[0]byte)(C._gotk4_flatpak1_TransactionClass_ready_pre_auth)
	}

	if _, ok := goval.(interface {
		Run(ctx context.Context) error
	}); ok {
		pclass.run = (*[0]byte)(C._gotk4_flatpak1_TransactionClass_run)
	}

	if _, ok := goval.(interface {
		WebflowDone(options *glib.Variant, id uint)
	}); ok {
		pclass.webflow_done = (*[0]byte)(C._gotk4_flatpak1_TransactionClass_webflow_done)
	}

	if _, ok := goval.(interface {
		WebflowStart(remote, url string, options *glib.Variant, id uint) bool
	}); ok {
		pclass.webflow_start = (*[0]byte)(C._gotk4_flatpak1_TransactionClass_webflow_start)
	}
}

//export _gotk4_flatpak1_TransactionClass_add_new_remote
func _gotk4_flatpak1_TransactionClass_add_new_remote(arg0 *C.FlatpakTransaction, arg1 C.FlatpakTransactionRemoteReason, arg2 *C.char, arg3 *C.char, arg4 *C.char) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		AddNewRemote(reason TransactionRemoteReason, fromId, remoteName, url string) bool
	})

	var _reason TransactionRemoteReason // out
	var _fromId string                  // out
	var _remoteName string              // out
	var _url string                     // out

	_reason = TransactionRemoteReason(arg1)
	_fromId = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_remoteName = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))
	_url = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))

	ok := iface.AddNewRemote(_reason, _fromId, _remoteName, _url)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_flatpak1_TransactionClass_basic_auth_start
func _gotk4_flatpak1_TransactionClass_basic_auth_start(arg0 *C.FlatpakTransaction, arg1 *C.char, arg2 *C.char, arg3 *C.GVariant, arg4 C.guint) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		BasicAuthStart(remote, realm string, options *glib.Variant, id uint) bool
	})

	var _remote string         // out
	var _realm string          // out
	var _options *glib.Variant // out
	var _id uint               // out

	_remote = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_realm = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_options = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	C.g_variant_ref(arg3)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_options)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	_id = uint(arg4)

	ok := iface.BasicAuthStart(_remote, _realm, _options, _id)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_flatpak1_TransactionClass_end_of_lifed
func _gotk4_flatpak1_TransactionClass_end_of_lifed(arg0 *C.FlatpakTransaction, arg1 *C.char, arg2 *C.char, arg3 *C.char) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		EndOfLifed(ref, reason, rebase string)
	})

	var _ref string    // out
	var _reason string // out
	var _rebase string // out

	_ref = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_reason = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_rebase = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))

	iface.EndOfLifed(_ref, _reason, _rebase)
}

//export _gotk4_flatpak1_TransactionClass_install_authenticator
func _gotk4_flatpak1_TransactionClass_install_authenticator(arg0 *C.FlatpakTransaction, arg1 *C.char, arg2 *C.char) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		InstallAuthenticator(remote, authenticatorRef string)
	})

	var _remote string           // out
	var _authenticatorRef string // out

	_remote = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_authenticatorRef = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	iface.InstallAuthenticator(_remote, _authenticatorRef)
}

//export _gotk4_flatpak1_TransactionClass_new_operation
func _gotk4_flatpak1_TransactionClass_new_operation(arg0 *C.FlatpakTransaction, arg1 *C.FlatpakTransactionOperation, arg2 *C.FlatpakTransactionProgress) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		NewOperation(operation *TransactionOperation, progress *TransactionProgress)
	})

	var _operation *TransactionOperation // out
	var _progress *TransactionProgress   // out

	_operation = wrapTransactionOperation(externglib.Take(unsafe.Pointer(arg1)))
	_progress = wrapTransactionProgress(externglib.Take(unsafe.Pointer(arg2)))

	iface.NewOperation(_operation, _progress)
}

//export _gotk4_flatpak1_TransactionClass_operation_done
func _gotk4_flatpak1_TransactionClass_operation_done(arg0 *C.FlatpakTransaction, arg1 *C.FlatpakTransactionOperation, arg2 *C.char, arg3 C.FlatpakTransactionResult) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		OperationDone(operation *TransactionOperation, commit string, details TransactionResult)
	})

	var _operation *TransactionOperation // out
	var _commit string                   // out
	var _details TransactionResult       // out

	_operation = wrapTransactionOperation(externglib.Take(unsafe.Pointer(arg1)))
	_commit = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_details = TransactionResult(arg3)

	iface.OperationDone(_operation, _commit, _details)
}

//export _gotk4_flatpak1_TransactionClass_operation_error
func _gotk4_flatpak1_TransactionClass_operation_error(arg0 *C.FlatpakTransaction, arg1 *C.FlatpakTransactionOperation, arg2 *C.GError, arg3 C.FlatpakTransactionErrorDetails) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		OperationError(operation *TransactionOperation, err error, detail TransactionErrorDetails) bool
	})

	var _operation *TransactionOperation // out
	var _err error                       // out
	var _detail TransactionErrorDetails  // out

	_operation = wrapTransactionOperation(externglib.Take(unsafe.Pointer(arg1)))
	_err = gerror.Take(unsafe.Pointer(arg2))
	_detail = TransactionErrorDetails(arg3)

	ok := iface.OperationError(_operation, _err, _detail)

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_flatpak1_TransactionClass_ready
func _gotk4_flatpak1_TransactionClass_ready(arg0 *C.FlatpakTransaction) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ Ready() bool })

	ok := iface.Ready()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_flatpak1_TransactionClass_ready_pre_auth
func _gotk4_flatpak1_TransactionClass_ready_pre_auth(arg0 *C.FlatpakTransaction) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface{ ReadyPreAuth() bool })

	ok := iface.ReadyPreAuth()

	if ok {
		cret = C.TRUE
	}

	return cret
}

//export _gotk4_flatpak1_TransactionClass_run
func _gotk4_flatpak1_TransactionClass_run(arg0 *C.FlatpakTransaction, arg1 *C.GCancellable, _cerr **C.GError) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		Run(ctx context.Context) error
	})

	var _cancellable context.Context // out

	if arg1 != nil {
		_cancellable = gcancel.NewCancellableContext(unsafe.Pointer(arg1))
	}

	_goerr := iface.Run(_cancellable)

	if _goerr != nil && _cerr != nil {
		*_cerr = (*C.GError)(gerror.New(_goerr))
	}

	return cret
}

//export _gotk4_flatpak1_TransactionClass_webflow_done
func _gotk4_flatpak1_TransactionClass_webflow_done(arg0 *C.FlatpakTransaction, arg1 *C.GVariant, arg2 C.guint) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		WebflowDone(options *glib.Variant, id uint)
	})

	var _options *glib.Variant // out
	var _id uint               // out

	_options = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.g_variant_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_options)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	_id = uint(arg2)

	iface.WebflowDone(_options, _id)
}

//export _gotk4_flatpak1_TransactionClass_webflow_start
func _gotk4_flatpak1_TransactionClass_webflow_start(arg0 *C.FlatpakTransaction, arg1 *C.char, arg2 *C.char, arg3 *C.GVariant, arg4 C.guint) (cret C.gboolean) {
	goval := externglib.GoPrivateFromObject(unsafe.Pointer(arg0))
	iface := goval.(interface {
		WebflowStart(remote, url string, options *glib.Variant, id uint) bool
	})

	var _remote string         // out
	var _url string            // out
	var _options *glib.Variant // out
	var _id uint               // out

	_remote = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_url = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_options = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	C.g_variant_ref(arg3)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_options)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	_id = uint(arg4)

	ok := iface.WebflowStart(_remote, _url, _options, _id)

	if ok {
		cret = C.TRUE
	}

	return cret
}

func wrapTransaction(obj *externglib.Object) *Transaction {
	return &Transaction{
		Object: obj,
		Initable: gio.Initable{
			Object: obj,
		},
	}
}

func marshalTransaction(p uintptr) (interface{}, error) {
	return wrapTransaction(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_flatpak1_Transaction_ConnectAddNewRemote
func _gotk4_flatpak1_Transaction_ConnectAddNewRemote(arg0 C.gpointer, arg1 C.gint, arg2 *C.gchar, arg3 *C.gchar, arg4 *C.gchar, arg5 C.guintptr) (cret C.gboolean) {
	var f func(reason TransactionRemoteReason, fromId, suggestedRemoteName, url string) (ok bool)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(reason TransactionRemoteReason, fromId, suggestedRemoteName, url string) (ok bool))
	}

	var _reason TransactionRemoteReason // out
	var _fromId string                  // out
	var _suggestedRemoteName string     // out
	var _url string                     // out

	_reason = TransactionRemoteReason(arg1)
	_fromId = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_suggestedRemoteName = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))
	_url = C.GoString((*C.gchar)(unsafe.Pointer(arg4)))

	ok := f(_reason, _fromId, _suggestedRemoteName, _url)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectAddNewRemote signal gets emitted if, as part of the transaction, it is
// required or recommended that a new remote is added, for the reason described
// in reason.
func (self *Transaction) ConnectAddNewRemote(f func(reason TransactionRemoteReason, fromId, suggestedRemoteName, url string) (ok bool)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "add-new-remote", false, unsafe.Pointer(C._gotk4_flatpak1_Transaction_ConnectAddNewRemote), f)
}

//export _gotk4_flatpak1_Transaction_ConnectBasicAuthStart
func _gotk4_flatpak1_Transaction_ConnectBasicAuthStart(arg0 C.gpointer, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.GVariant, arg4 C.gint, arg5 C.guintptr) (cret C.gboolean) {
	var f func(remote, realm string, options *glib.Variant, id int) (ok bool)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(remote, realm string, options *glib.Variant, id int) (ok bool))
	}

	var _remote string         // out
	var _realm string          // out
	var _options *glib.Variant // out
	var _id int                // out

	_remote = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_realm = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_options = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	C.g_variant_ref(arg3)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_options)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	_id = int(arg4)

	ok := f(_remote, _realm, _options, _id)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectBasicAuthStart signal gets emitted when a basic user/password
// authentication is needed during the operation. If the caller handles this it
// should ask the user for the user and password and return TRUE. Once the
// information is gathered call flatpak_transaction_complete_basic_auth() with
// it.
//
// If the client does not support basic auth then return FALSE from this signal
// (or don't implement it). This will abort the authentication and likely result
// in the transaction failing (unless the authentication was somehow optional).
func (self *Transaction) ConnectBasicAuthStart(f func(remote, realm string, options *glib.Variant, id int) (ok bool)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "basic-auth-start", false, unsafe.Pointer(C._gotk4_flatpak1_Transaction_ConnectBasicAuthStart), f)
}

//export _gotk4_flatpak1_Transaction_ConnectEndOfLifed
func _gotk4_flatpak1_Transaction_ConnectEndOfLifed(arg0 C.gpointer, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.gchar, arg4 C.guintptr) {
	var f func(ref, reason, rebase string)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(ref, reason, rebase string))
	}

	var _ref string    // out
	var _reason string // out
	var _rebase string // out

	_ref = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_reason = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_rebase = C.GoString((*C.gchar)(unsafe.Pointer(arg3)))

	f(_ref, _reason, _rebase)
}

// ConnectEndOfLifed signal gets emitted when a ref is found to be marked as
// end-of-life during the execution of the transaction.
func (self *Transaction) ConnectEndOfLifed(f func(ref, reason, rebase string)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "end-of-lifed", false, unsafe.Pointer(C._gotk4_flatpak1_Transaction_ConnectEndOfLifed), f)
}

//export _gotk4_flatpak1_Transaction_ConnectInstallAuthenticator
func _gotk4_flatpak1_Transaction_ConnectInstallAuthenticator(arg0 C.gpointer, arg1 *C.gchar, arg2 *C.gchar, arg3 C.guintptr) {
	var f func(remote, authenticatorRef string)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(remote, authenticatorRef string))
	}

	var _remote string           // out
	var _authenticatorRef string // out

	_remote = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_authenticatorRef = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))

	f(_remote, _authenticatorRef)
}

// ConnectInstallAuthenticator signal gets emitted if, as part of resolving the
// transaction, we need to use an authenticator, but the authentication is not
// installed, but is available to be installed from the ref.
//
// The application can handle this signal, and if so create another transaction
// to install the authenticator.
//
// The default handler does nothing, and if the authenticator is not installed
// when the signal handler fails the transaction will error out.
func (self *Transaction) ConnectInstallAuthenticator(f func(remote, authenticatorRef string)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "install-authenticator", false, unsafe.Pointer(C._gotk4_flatpak1_Transaction_ConnectInstallAuthenticator), f)
}

//export _gotk4_flatpak1_Transaction_ConnectNewOperation
func _gotk4_flatpak1_Transaction_ConnectNewOperation(arg0 C.gpointer, arg1 *C.FlatpakTransactionOperation, arg2 *C.FlatpakTransactionProgress, arg3 C.guintptr) {
	var f func(operation *TransactionOperation, progress *TransactionProgress)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(operation *TransactionOperation, progress *TransactionProgress))
	}

	var _operation *TransactionOperation // out
	var _progress *TransactionProgress   // out

	_operation = wrapTransactionOperation(externglib.Take(unsafe.Pointer(arg1)))
	_progress = wrapTransactionProgress(externglib.Take(unsafe.Pointer(arg2)))

	f(_operation, _progress)
}

// ConnectNewOperation signal gets emitted during the execution of the
// transaction when a new operation is beginning.
func (self *Transaction) ConnectNewOperation(f func(operation *TransactionOperation, progress *TransactionProgress)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "new-operation", false, unsafe.Pointer(C._gotk4_flatpak1_Transaction_ConnectNewOperation), f)
}

//export _gotk4_flatpak1_Transaction_ConnectOperationDone
func _gotk4_flatpak1_Transaction_ConnectOperationDone(arg0 C.gpointer, arg1 *C.FlatpakTransactionOperation, arg2 *C.gchar, arg3 C.gint, arg4 C.guintptr) {
	var f func(operation *TransactionOperation, commit string, result TransactionResult)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(operation *TransactionOperation, commit string, result TransactionResult))
	}

	var _operation *TransactionOperation // out
	var _commit string                   // out
	var _result TransactionResult        // out

	_operation = wrapTransactionOperation(externglib.Take(unsafe.Pointer(arg1)))
	if arg2 != nil {
		_commit = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	}
	_result = TransactionResult(arg3)

	f(_operation, _commit, _result)
}

// ConnectOperationDone signal gets emitted during the execution of the
// transaction when an operation is finished.
func (self *Transaction) ConnectOperationDone(f func(operation *TransactionOperation, commit string, result TransactionResult)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "operation-done", false, unsafe.Pointer(C._gotk4_flatpak1_Transaction_ConnectOperationDone), f)
}

//export _gotk4_flatpak1_Transaction_ConnectOperationError
func _gotk4_flatpak1_Transaction_ConnectOperationError(arg0 C.gpointer, arg1 *C.FlatpakTransactionOperation, arg2 *C.GError, arg3 C.gint, arg4 C.guintptr) (cret C.gboolean) {
	var f func(operation *TransactionOperation, err error, details TransactionErrorDetails) (ok bool)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg4))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(operation *TransactionOperation, err error, details TransactionErrorDetails) (ok bool))
	}

	var _operation *TransactionOperation // out
	var _err error                       // out
	var _details TransactionErrorDetails // out

	_operation = wrapTransactionOperation(externglib.Take(unsafe.Pointer(arg1)))
	_err = gerror.Take(unsafe.Pointer(arg2))
	_details = TransactionErrorDetails(arg3)

	ok := f(_operation, _err, _details)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectOperationError signal gets emitted when an error occurs during the
// execution of the transaction.
func (self *Transaction) ConnectOperationError(f func(operation *TransactionOperation, err error, details TransactionErrorDetails) (ok bool)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "operation-error", false, unsafe.Pointer(C._gotk4_flatpak1_Transaction_ConnectOperationError), f)
}

//export _gotk4_flatpak1_Transaction_ConnectReady
func _gotk4_flatpak1_Transaction_ConnectReady(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectReady signal is emitted when all the refs involved in the operation
// have been resolved to commits, and the required authentication for all ops is
// gotten. At this point flatpak_transaction_get_operations() will return all
// the operations that will be executed as part of the transaction.
func (self *Transaction) ConnectReady(f func() (ok bool)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "ready", false, unsafe.Pointer(C._gotk4_flatpak1_Transaction_ConnectReady), f)
}

//export _gotk4_flatpak1_Transaction_ConnectReadyPreAuth
func _gotk4_flatpak1_Transaction_ConnectReadyPreAuth(arg0 C.gpointer, arg1 C.guintptr) (cret C.gboolean) {
	var f func() (ok bool)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func() (ok bool))
	}

	ok := f()

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectReadyPreAuth signal is emitted when all the refs involved in the
// transaction have been resolved to commits, but we might not necessarily have
// asked for authenticaion for all their required operations. This is very
// similar to the ::ready signal, and you can chose which one (or both) to use
// depending on how you want to handle authentication in your user interface.
//
// At this point flatpak_transaction_get_operations() will return all the
// operations that will be executed as part of the transaction. You can call
// flatpak_transaction_operation_get_requires_authentication() to see which will
// require authentication.
func (self *Transaction) ConnectReadyPreAuth(f func() (ok bool)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "ready-pre-auth", false, unsafe.Pointer(C._gotk4_flatpak1_Transaction_ConnectReadyPreAuth), f)
}

//export _gotk4_flatpak1_Transaction_ConnectWebflowDone
func _gotk4_flatpak1_Transaction_ConnectWebflowDone(arg0 C.gpointer, arg1 *C.GVariant, arg2 C.gint, arg3 C.guintptr) {
	var f func(options *glib.Variant, id int)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg3))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(options *glib.Variant, id int))
	}

	var _options *glib.Variant // out
	var _id int                // out

	_options = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg1)))
	C.g_variant_ref(arg1)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_options)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	_id = int(arg2)

	f(_options, _id)
}

// ConnectWebflowDone signal gets emitted when the authentication finished the
// webflow, independent of the reason and results. If you for were showing a
// web-browser window it can now be closed.
func (self *Transaction) ConnectWebflowDone(f func(options *glib.Variant, id int)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "webflow-done", false, unsafe.Pointer(C._gotk4_flatpak1_Transaction_ConnectWebflowDone), f)
}

//export _gotk4_flatpak1_Transaction_ConnectWebflowStart
func _gotk4_flatpak1_Transaction_ConnectWebflowStart(arg0 C.gpointer, arg1 *C.gchar, arg2 *C.gchar, arg3 *C.GVariant, arg4 C.gint, arg5 C.guintptr) (cret C.gboolean) {
	var f func(remote, url string, options *glib.Variant, id int) (ok bool)
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg5))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func(remote, url string, options *glib.Variant, id int) (ok bool))
	}

	var _remote string         // out
	var _url string            // out
	var _options *glib.Variant // out
	var _id int                // out

	_remote = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_url = C.GoString((*C.gchar)(unsafe.Pointer(arg2)))
	_options = (*glib.Variant)(gextras.NewStructNative(unsafe.Pointer(arg3)))
	C.g_variant_ref(arg3)
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_options)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_variant_unref((*C.GVariant)(intern.C))
		},
	)
	_id = int(arg4)

	ok := f(_remote, _url, _options, _id)

	if ok {
		cret = C.TRUE
	}

	return cret
}

// ConnectWebflowStart signal gets emitted when some kind of user authentication
// is needed during the operation. If the caller handles this it should show the
// url in a webbrowser and return TRUE. This will eventually cause the
// webbrowser to finish the authentication operation and operation will
// continue, as signaled by the webflow-done being emitted.
//
// If the client does not support webflow then return FALSE from this signal (or
// don't implement it). This will abort the authentication and likely result in
// the transaction failing (unless the authentication was somehow optional).
//
// During the time between webflow-start and webflow-done the client can call
// flatpak_transaction_abort_webflow() to manually abort the authentication.
// This is useful if the user aborted the authentication operation some way,
// like e.g. closing the browser window.
func (self *Transaction) ConnectWebflowStart(f func(remote, url string, options *glib.Variant, id int) (ok bool)) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "webflow-start", false, unsafe.Pointer(C._gotk4_flatpak1_Transaction_ConnectWebflowStart), f)
}

// NewTransactionForInstallation creates a new Transaction object that can be
// used to do installation and updates of multiple refs, as well as their
// dependencies, in a single operation. Set the options you want on the
// transaction and add the refs you want to install/update, then start the
// transaction with flatpak_transaction_run ().
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - installation: Installation.
//
// The function returns the following values:
//
//    - transaction or NULL on failure.
//
func NewTransactionForInstallation(ctx context.Context, installation *Installation) (*Transaction, error) {
	var _arg2 *C.GCancellable        // out
	var _arg1 *C.FlatpakInstallation // out
	var _cret *C.FlatpakTransaction  // in
	var _cerr *C.GError              // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(installation).Native()))

	_cret = C.flatpak_transaction_new_for_installation(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(installation)

	var _transaction *Transaction // out
	var _goerr error              // out

	_transaction = wrapTransaction(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _transaction, _goerr
}

// AbortWebflow: cancel an ongoing webflow authentication request. This can be
// call in the time between Transaction::webflow-start returned TRUE, and
// Transaction::webflow-done is emitted. It will cancel the ongoing
// authentication operation.
//
// This is useful for example if you're showing an authenticaion window with a
// browser, but the user closed it before it was finished.
//
// The function takes the following parameters:
//
//    - id: webflow id, as passed into the webflow-start signal.
//
func (self *Transaction) AbortWebflow(id uint) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 C.guint               // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.guint(id)

	C.flatpak_transaction_abort_webflow(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(id)
}

// AddDefaultDependencySources: similar to
// flatpak_transaction_add_dependency_source(), but adds all the default
// installations, which means all the defined system-wide (but not per-user)
// installations.
func (self *Transaction) AddDefaultDependencySources() {
	var _arg0 *C.FlatpakTransaction // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))

	C.flatpak_transaction_add_default_dependency_sources(_arg0)
	runtime.KeepAlive(self)
}

// AddDependencySource adds an extra installation as a source for application
// dependencies. This means that applications can be installed in this
// transaction relying on runtimes from this additional installation (whereas it
// would normally install required runtimes that are not installed in the
// installation the transaction works on).
//
// Also see flatpak_transaction_add_default_dependency_sources().
//
// The function takes the following parameters:
//
//    - installation: Installation.
//
func (self *Transaction) AddDependencySource(installation *Installation) {
	var _arg0 *C.FlatpakTransaction  // out
	var _arg1 *C.FlatpakInstallation // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(installation).Native()))

	C.flatpak_transaction_add_dependency_source(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(installation)
}

// AddInstall adds installing the given ref to this transaction.
//
// The remote can either be a configured remote of the installation, or a
// file:// uri pointing at a local repository to install from, in which case an
// origin remote is created.
//
// The function takes the following parameters:
//
//    - remote: name of the remote.
//    - ref: ref.
//    - subpaths (optional) to install, or the empty list or NULL to pull all
//      subpaths.
//
func (self *Transaction) AddInstall(remote, ref string, subpaths []string) error {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 *C.char               // out
	var _arg2 *C.char               // out
	var _arg3 **C.char              // out
	var _cerr *C.GError             // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(remote)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(ref)))
	defer C.free(unsafe.Pointer(_arg2))
	{
		_arg3 = (**C.char)(C.calloc(C.size_t((len(subpaths) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg3))
		{
			out := unsafe.Slice(_arg3, len(subpaths)+1)
			var zero *C.char
			out[len(subpaths)] = zero
			for i := range subpaths {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(subpaths[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}

	C.flatpak_transaction_add_install(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(remote)
	runtime.KeepAlive(ref)
	runtime.KeepAlive(subpaths)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddInstallBundle adds installing the given bundle to this transaction.
//
// The function takes the following parameters:
//
//    - file that is an flatpak bundle.
//    - gpgData (optional): GPG key with which to check bundle signatures, or
//      NULL to use the key embedded in the bundle (if any).
//
func (self *Transaction) AddInstallBundle(file gio.Filer, gpgData *glib.Bytes) error {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 *C.GFile              // out
	var _arg2 *C.GBytes             // out
	var _cerr *C.GError             // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.GFile)(unsafe.Pointer(externglib.InternObject(file).Native()))
	if gpgData != nil {
		_arg2 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(gpgData)))
	}

	C.flatpak_transaction_add_install_bundle(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(file)
	runtime.KeepAlive(gpgData)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddInstallFlatpakref adds installing the given flatpakref to this
// transaction.
//
// The function takes the following parameters:
//
//    - flatpakrefData: data from a flatpakref file.
//
func (self *Transaction) AddInstallFlatpakref(flatpakrefData *glib.Bytes) error {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 *C.GBytes             // out
	var _cerr *C.GError             // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(flatpakrefData)))

	C.flatpak_transaction_add_install_flatpakref(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(flatpakrefData)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddSideloadRepo adds an extra local ostree repo as source for installation.
// This is equivalent to using the sideload-repos directories (see flatpak(1)),
// but can be done dynamically. Any path added here is used in addition to ones
// in those directories.
//
// The function takes the following parameters:
//
//    - path to a local flatpak repository.
//
func (self *Transaction) AddSideloadRepo(path string) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 *C.char               // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(path)))
	defer C.free(unsafe.Pointer(_arg1))

	C.flatpak_transaction_add_sideload_repo(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(path)
}

// AddUninstall adds uninstalling the given ref to this transaction.
//
// The function takes the following parameters:
//
//    - ref: ref.
//
func (self *Transaction) AddUninstall(ref string) error {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 *C.char               // out
	var _cerr *C.GError             // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(ref)))
	defer C.free(unsafe.Pointer(_arg1))

	C.flatpak_transaction_add_uninstall(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ref)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// AddUpdate adds updating the given ref to this transaction.
//
// The function takes the following parameters:
//
//    - ref: ref.
//    - subpaths (optional) to install; NULL to use the current set plus the set
//      of configured languages, or { NULL } or { "", NULL } to pull all
//      subpaths.
//    - commit (optional) to update to, or NULL to use the latest.
//
func (self *Transaction) AddUpdate(ref string, subpaths []string, commit string) error {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 *C.char               // out
	var _arg2 **C.char              // out
	var _arg3 *C.char               // out
	var _cerr *C.GError             // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(ref)))
	defer C.free(unsafe.Pointer(_arg1))
	{
		_arg2 = (**C.char)(C.calloc(C.size_t((len(subpaths) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg2))
		{
			out := unsafe.Slice(_arg2, len(subpaths)+1)
			var zero *C.char
			out[len(subpaths)] = zero
			for i := range subpaths {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(subpaths[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	if commit != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(commit)))
		defer C.free(unsafe.Pointer(_arg3))
	}

	C.flatpak_transaction_add_update(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ref)
	runtime.KeepAlive(subpaths)
	runtime.KeepAlive(commit)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CompleteBasicAuth finishes (or aborts) an ongoing basic auth request.
//
// The function takes the following parameters:
//
//    - id: webflow id, as passed into the webflow-start signal.
//    - user name, or NULL if aborting request.
//    - password: password.
//    - options: extra a{sv] variant with options (or NULL), currently unused.
//
func (self *Transaction) CompleteBasicAuth(id uint, user, password string, options *glib.Variant) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 C.guint               // out
	var _arg2 *C.char               // out
	var _arg3 *C.char               // out
	var _arg4 *C.GVariant           // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.guint(id)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(user)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(password)))
	defer C.free(unsafe.Pointer(_arg3))
	_arg4 = (*C.GVariant)(gextras.StructNative(unsafe.Pointer(options)))

	C.flatpak_transaction_complete_basic_auth(_arg0, _arg1, _arg2, _arg3, _arg4)
	runtime.KeepAlive(self)
	runtime.KeepAlive(id)
	runtime.KeepAlive(user)
	runtime.KeepAlive(password)
	runtime.KeepAlive(options)
}

// CurrentOperation gets the current operation.
//
// The function returns the following values:
//
//    - transactionOperation: current TransactionOperation.
//
func (self *Transaction) CurrentOperation() *TransactionOperation {
	var _arg0 *C.FlatpakTransaction          // out
	var _cret *C.FlatpakTransactionOperation // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_get_current_operation(_arg0)
	runtime.KeepAlive(self)

	var _transactionOperation *TransactionOperation // out

	_transactionOperation = wrapTransactionOperation(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _transactionOperation
}

// IncludeUnusedUninstallOps gets the value set by
// flatpak_transaction_set_include_unused_uninstall_ops().
//
// The function returns the following values:
//
//    - ok: TRUE if include_unused_uninstall_ops is set, FALSE otherwise.
//
func (self *Transaction) IncludeUnusedUninstallOps() bool {
	var _arg0 *C.FlatpakTransaction // out
	var _cret C.gboolean            // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_get_include_unused_uninstall_ops(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Installation gets the installation this transaction was created for.
//
// The function returns the following values:
//
//    - installation: Installation.
//
func (self *Transaction) Installation() *Installation {
	var _arg0 *C.FlatpakTransaction  // out
	var _cret *C.FlatpakInstallation // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_get_installation(_arg0)
	runtime.KeepAlive(self)

	var _installation *Installation // out

	_installation = wrapInstallation(externglib.AssumeOwnership(unsafe.Pointer(_cret)))

	return _installation
}

// NoDeploy gets whether the transaction is only downloading updates, and not
// deploying them.
//
// The function returns the following values:
//
//    - ok: TRUE if no_deploy is set, FALSE otherwise.
//
func (self *Transaction) NoDeploy() bool {
	var _arg0 *C.FlatpakTransaction // out
	var _cret C.gboolean            // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_get_no_deploy(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// NoPull gets whether the transaction should operate only on locally available
// data.
//
// The function returns the following values:
//
//    - ok: TRUE if no_pull is set, FALSE otherwise.
//
func (self *Transaction) NoPull() bool {
	var _arg0 *C.FlatpakTransaction // out
	var _cret C.gboolean            // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_get_no_pull(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Operations gets the list of operations. Skipped operations are not included.
// The order of the list is the order in which the operations are executed.
//
// The function returns the following values:
//
//    - list of operations.
//
func (self *Transaction) Operations() []*TransactionOperation {
	var _arg0 *C.FlatpakTransaction // out
	var _cret *C.GList              // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_get_operations(_arg0)
	runtime.KeepAlive(self)

	var _list []*TransactionOperation // out

	_list = make([]*TransactionOperation, 0, gextras.ListSize(unsafe.Pointer(_cret)))
	gextras.MoveList(unsafe.Pointer(_cret), true, func(v unsafe.Pointer) {
		src := (*C.FlatpakTransactionOperation)(v)
		var dst *TransactionOperation // out
		dst = wrapTransactionOperation(externglib.AssumeOwnership(unsafe.Pointer(src)))
		_list = append(_list, dst)
	})

	return _list
}

// ParentWindow gets the parent window set for this transaction, or NULL if
// unset. See flatpak_transaction_get_parent_window().
//
// The function returns the following values:
//
//    - utf8: window name, or NULL.
//
func (self *Transaction) ParentWindow() string {
	var _arg0 *C.FlatpakTransaction // out
	var _cret *C.char               // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_get_parent_window(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsEmpty returns whether the transaction contains any non-skipped operations.
//
// The function returns the following values:
//
//    - ok: TRUE if the transaction is empty.
//
func (self *Transaction) IsEmpty() bool {
	var _arg0 *C.FlatpakTransaction // out
	var _cret C.gboolean            // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_is_empty(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Run executes the transaction.
//
// During the course of the execution, various signals will get emitted. The
// FlatpakTransaction::choose-remote-for-ref and Transaction::add-new-remote
// signals may get emitted while resolving operations. Transaction::ready is
// emitted when the transaction has been fully resolved, and
// Transaction::new-operation and Transaction::operation-done are emitted while
// the operations are carried out. If an error occurs at any point during the
// execution, Transaction::operation-error is emitted.
//
// Note that this call blocks until the transaction is done.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//
func (transaction *Transaction) Run(ctx context.Context) error {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 *C.GCancellable       // out
	var _cerr *C.GError             // in

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(transaction).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.flatpak_transaction_run(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(transaction)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetDefaultArch sets the architecture to default to where it is unspecified.
//
// The function takes the following parameters:
//
//    - arch to make default.
//
func (self *Transaction) SetDefaultArch(arch string) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 *C.char               // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(arch)))
	defer C.free(unsafe.Pointer(_arg1))

	C.flatpak_transaction_set_default_arch(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(arch)
}

// SetDisableAutoPIN: normally the transaction pins any explicit installations
// so they will not be automatically removed. But this can be disabled if you
// don't want this behaviour.
//
// The function takes the following parameters:
//
//    - disablePin: whether to disable auto-pinning.
//
func (self *Transaction) SetDisableAutoPIN(disablePin bool) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if disablePin {
		_arg1 = C.TRUE
	}

	C.flatpak_transaction_set_disable_auto_pin(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(disablePin)
}

// SetDisableDependencies sets whether the transaction should ignore runtime
// dependencies when resolving operations for applications.
//
// The function takes the following parameters:
//
//    - disableDependencies: whether to disable runtime dependencies.
//
func (self *Transaction) SetDisableDependencies(disableDependencies bool) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if disableDependencies {
		_arg1 = C.TRUE
	}

	C.flatpak_transaction_set_disable_dependencies(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(disableDependencies)
}

// SetDisablePrune sets whether the transaction should avoid pruning the local
// OSTree repository after updating.
//
// The function takes the following parameters:
//
//    - disablePrune: whether to avoid pruning.
//
func (self *Transaction) SetDisablePrune(disablePrune bool) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if disablePrune {
		_arg1 = C.TRUE
	}

	C.flatpak_transaction_set_disable_prune(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(disablePrune)
}

// SetDisableRelated sets whether the transaction should avoid adding related
// refs when resolving operations. Related refs are extensions that are
// suggested by apps, such as locales.
//
// The function takes the following parameters:
//
//    - disableRelated: whether to avoid adding related refs.
//
func (self *Transaction) SetDisableRelated(disableRelated bool) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if disableRelated {
		_arg1 = C.TRUE
	}

	C.flatpak_transaction_set_disable_related(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(disableRelated)
}

// SetDisableStaticDeltas sets whether the transaction should avoid using static
// deltas when pulling.
//
// The function takes the following parameters:
//
//    - disableStaticDeltas: whether to avoid static deltas.
//
func (self *Transaction) SetDisableStaticDeltas(disableStaticDeltas bool) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if disableStaticDeltas {
		_arg1 = C.TRUE
	}

	C.flatpak_transaction_set_disable_static_deltas(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(disableStaticDeltas)
}

// SetForceUninstall sets whether the transaction should uninstall files even if
// they're used by a running application.
//
// The function takes the following parameters:
//
//    - forceUninstall: whether to force-uninstall refs.
//
func (self *Transaction) SetForceUninstall(forceUninstall bool) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if forceUninstall {
		_arg1 = C.TRUE
	}

	C.flatpak_transaction_set_force_uninstall(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(forceUninstall)
}

// SetIncludeUnusedUninstallOps: when this is set to TRUE, Flatpak will add
// uninstall operations to the transaction for each runtime it considers unused.
// This is used by the "update" CLI command to garbage collect runtimes and free
// disk space.
//
// No guarantees are made about the exact hueristic used; e.g. only end-of-life
// unused runtimes may be uninstalled with this set. To see the full list of
// unused runtimes in an installation, use
// flatpak_installation_list_unused_refs().
//
// The function takes the following parameters:
//
//    - includeUnusedUninstallOps: whether to include unused uninstall ops.
//
func (self *Transaction) SetIncludeUnusedUninstallOps(includeUnusedUninstallOps bool) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if includeUnusedUninstallOps {
		_arg1 = C.TRUE
	}

	C.flatpak_transaction_set_include_unused_uninstall_ops(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(includeUnusedUninstallOps)
}

// SetNoDeploy sets whether the transaction should download updates, but not
// deploy them.
//
// The function takes the following parameters:
//
//    - noDeploy: whether to avoid deploying.
//
func (self *Transaction) SetNoDeploy(noDeploy bool) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if noDeploy {
		_arg1 = C.TRUE
	}

	C.flatpak_transaction_set_no_deploy(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(noDeploy)
}

// SetNoInteraction: this method can be used to prevent interactive
// authorization dialogs to appear for operations on self. This is useful for
// background operations that are not directly triggered by a user action.
//
// By default, the setting from the parent Installation is used.
//
// The function takes the following parameters:
//
//    - noInteraction: whether to disallow interactive authorization for
//      operations.
//
func (self *Transaction) SetNoInteraction(noInteraction bool) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if noInteraction {
		_arg1 = C.TRUE
	}

	C.flatpak_transaction_set_no_interaction(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(noInteraction)
}

// SetNoPull sets whether the transaction should operate only on locally
// available data.
//
// The function takes the following parameters:
//
//    - noPull: whether to avoid pulls.
//
func (self *Transaction) SetNoPull(noPull bool) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if noPull {
		_arg1 = C.TRUE
	}

	C.flatpak_transaction_set_no_pull(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(noPull)
}

// SetParentWindow sets the parent window (if any) to use for any UI show by
// this transaction. This is used by authenticators if they need to interact
// with the user during authentication.
//
// The format of this string depends on the display system in use, and is the
// same as used by xdg-desktop-portal.
//
// On X11 it should be of the form x11:$xid where $xid is the hex version of the
// xwindows id.
//
// On wayland is should be wayland:$handle where handle is gotten by using the
// export call of the xdg-foreign-unstable wayland extension.
//
// The function takes the following parameters:
//
//    - parentWindow: whether to avoid pulls.
//
func (self *Transaction) SetParentWindow(parentWindow string) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 *C.char               // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(parentWindow)))
	defer C.free(unsafe.Pointer(_arg1))

	C.flatpak_transaction_set_parent_window(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(parentWindow)
}

// SetReinstall sets whether the transaction should uninstall first if a ref is
// already installed.
//
// The function takes the following parameters:
//
//    - reinstall: whether to reinstall refs.
//
func (self *Transaction) SetReinstall(reinstall bool) {
	var _arg0 *C.FlatpakTransaction // out
	var _arg1 C.gboolean            // out

	_arg0 = (*C.FlatpakTransaction)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if reinstall {
		_arg1 = C.TRUE
	}

	C.flatpak_transaction_set_reinstall(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(reinstall)
}

// TransactionOperationOverrider contains methods that are overridable.
type TransactionOperationOverrider interface {
}

type TransactionOperation struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*TransactionOperation)(nil)
)

func classInitTransactionOperationer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapTransactionOperation(obj *externglib.Object) *TransactionOperation {
	return &TransactionOperation{
		Object: obj,
	}
}

func marshalTransactionOperation(p uintptr) (interface{}, error) {
	return wrapTransactionOperation(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// BundlePath gets the path to the bundle.
//
// The function returns the following values:
//
//    - file: bundle #GFile or NULL.
//
func (self *TransactionOperation) BundlePath() *gio.File {
	var _arg0 *C.FlatpakTransactionOperation // out
	var _cret *C.GFile                       // in

	_arg0 = (*C.FlatpakTransactionOperation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_operation_get_bundle_path(_arg0)
	runtime.KeepAlive(self)

	var _file *gio.File // out

	{
		obj := externglib.Take(unsafe.Pointer(_cret))
		_file = &gio.File{
			Object: obj,
		}
	}

	return _file
}

// Commit gets the commit ID for the operation.
//
// This information is available when the transaction is resolved, i.e. when
// Transaction::ready is emitted.
//
// The function returns the following values:
//
//    - utf8: commit ID.
//
func (self *TransactionOperation) Commit() string {
	var _arg0 *C.FlatpakTransactionOperation // out
	var _cret *C.char                        // in

	_arg0 = (*C.FlatpakTransactionOperation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_operation_get_commit(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// DownloadSize gets the maximum download size for the operation.
//
// Note that this does not include the size of dependencies, and the actual
// download may be smaller, if some of the data is already available locally.
//
// For uninstall operations, this returns 0.
//
// This information is available when the transaction is resolved, i.e. when
// Transaction::ready is emitted.
//
// The function returns the following values:
//
//    - guint64: download size, in bytes.
//
func (self *TransactionOperation) DownloadSize() uint64 {
	var _arg0 *C.FlatpakTransactionOperation // out
	var _cret C.guint64                      // in

	_arg0 = (*C.FlatpakTransactionOperation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_operation_get_download_size(_arg0)
	runtime.KeepAlive(self)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// InstalledSize gets the installed size for the operation.
//
// Note that even for a new install, the extra space required on disk may be
// smaller than this number, if some of the data is already available locally.
//
// For uninstall operations, this returns 0.
//
// This information is available when the transaction is resolved, i.e. when
// Transaction::ready is emitted.
//
// The function returns the following values:
//
//    - guint64: installed size, in bytes.
//
func (self *TransactionOperation) InstalledSize() uint64 {
	var _arg0 *C.FlatpakTransactionOperation // out
	var _cret C.guint64                      // in

	_arg0 = (*C.FlatpakTransactionOperation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_operation_get_installed_size(_arg0)
	runtime.KeepAlive(self)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// IsSkipped gets whether this operation will be skipped when the transaction is
// run. Operations are skipped in some transaction situations, for example when
// an app has reached end of life and needs a rebase, or when it would have been
// updated but no update is available. By default, skipped operations are not
// returned by flatpak_transaction_get_operations()  but they can be accessed
// by traversing the operation graph using
// flatpak_transaction_operation_get_related_to_ops().
//
// The function returns the following values:
//
//    - ok: TRUE if the operation has been marked as to skip, FALSE otherwise.
//
func (self *TransactionOperation) IsSkipped() bool {
	var _arg0 *C.FlatpakTransactionOperation // out
	var _cret C.gboolean                     // in

	_arg0 = (*C.FlatpakTransactionOperation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_operation_get_is_skipped(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Metadata gets the metadata that will be applicable when the operation is
// done.
//
// This can be compared to the current metadata returned by
// flatpak_transaction_operation_get_old_metadata() to find new required
// permissions and similar changes.
//
// This information is available when the transaction is resolved, i.e. when
// Transaction::ready is emitted.
//
// The function returns the following values:
//
//    - keyFile: metadata File.
//
func (self *TransactionOperation) Metadata() *glib.KeyFile {
	var _arg0 *C.FlatpakTransactionOperation // out
	var _cret *C.GKeyFile                    // in

	_arg0 = (*C.FlatpakTransactionOperation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_operation_get_metadata(_arg0)
	runtime.KeepAlive(self)

	var _keyFile *glib.KeyFile // out

	_keyFile = (*glib.KeyFile)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _keyFile
}

// OldMetadata gets the metadata current metadata for the ref that self works
// on. Also see flatpak_transaction_operation_get_metadata().
//
// This information is available when the transaction is resolved, i.e. when
// Transaction::ready is emitted.
//
// The function returns the following values:
//
//    - keyFile: old metadata File.
//
func (self *TransactionOperation) OldMetadata() *glib.KeyFile {
	var _arg0 *C.FlatpakTransactionOperation // out
	var _cret *C.GKeyFile                    // in

	_arg0 = (*C.FlatpakTransactionOperation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_operation_get_old_metadata(_arg0)
	runtime.KeepAlive(self)

	var _keyFile *glib.KeyFile // out

	_keyFile = (*glib.KeyFile)(gextras.NewStructNative(unsafe.Pointer(_cret)))

	return _keyFile
}

// OperationType gets the type of the operation.
//
// The function returns the following values:
//
//    - transactionOperationType: type of operation, as TransactionOperationType.
//
func (self *TransactionOperation) OperationType() TransactionOperationType {
	var _arg0 *C.FlatpakTransactionOperation    // out
	var _cret C.FlatpakTransactionOperationType // in

	_arg0 = (*C.FlatpakTransactionOperation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_operation_get_operation_type(_arg0)
	runtime.KeepAlive(self)

	var _transactionOperationType TransactionOperationType // out

	_transactionOperationType = TransactionOperationType(_cret)

	return _transactionOperationType
}

// Remote gets the remote that the operation applies to.
//
// The function returns the following values:
//
//    - utf8: remote.
//
func (self *TransactionOperation) Remote() string {
	var _arg0 *C.FlatpakTransactionOperation // out
	var _cret *C.char                        // in

	_arg0 = (*C.FlatpakTransactionOperation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_operation_get_remote(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// RequiresAuthentication gets whether the given operation will require
// authentication to acquire needed tokens. See also the documentation for
// Transaction::ready-pre-auth.
//
// The function returns the following values:
//
//    - ok: whether self requires authentication.
//
func (self *TransactionOperation) RequiresAuthentication() bool {
	var _arg0 *C.FlatpakTransactionOperation // out
	var _cret C.gboolean                     // in

	_arg0 = (*C.FlatpakTransactionOperation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_operation_get_requires_authentication(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Subpaths gets the set of subpaths that will be pulled from this ref.
//
// Some refs are only partially installed, such as translations. These are
// subset by the toplevel directory (typically by translation name). The subset
// to install can be specified at install time, but is otherwise decided based
// on configurations and things like the current locale and how the app was
// previously installed.
//
// If there is no subsetting active, this will always return NULL (even though
// some other APIs also take an empty string to mean no subsetting).
//
// This information is available when the transaction is resolved, i.e. when
// Transaction::ready is emitted.
//
// The function returns the following values:
//
//    - utf8s: set of subpaths that will be pulled, or NULL if no subsetting.
//
func (self *TransactionOperation) Subpaths() []string {
	var _arg0 *C.FlatpakTransactionOperation // out
	var _cret **C.char                       // in

	_arg0 = (*C.FlatpakTransactionOperation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_operation_get_subpaths(_arg0)
	runtime.KeepAlive(self)

	var _utf8s []string // out

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// TransactionProgressOverrider contains methods that are overridable.
type TransactionProgressOverrider interface {
}

type TransactionProgress struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*TransactionProgress)(nil)
)

func classInitTransactionProgresser(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapTransactionProgress(obj *externglib.Object) *TransactionProgress {
	return &TransactionProgress{
		Object: obj,
	}
}

func marshalTransactionProgress(p uintptr) (interface{}, error) {
	return wrapTransactionProgress(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

//export _gotk4_flatpak1_TransactionProgress_ConnectChanged
func _gotk4_flatpak1_TransactionProgress_ConnectChanged(arg0 C.gpointer, arg1 C.guintptr) {
	var f func()
	{
		closure := externglib.ConnectedGeneratedClosure(uintptr(arg1))
		if closure == nil {
			panic("given unknown closure user_data")
		}
		defer closure.TryRepanic()

		f = closure.Func.(func())
	}

	f()
}

// ConnectChanged is emitted when some detail of the progress object changes,
// you can call the various methods to get the current status.
func (self *TransactionProgress) ConnectChanged(f func()) externglib.SignalHandle {
	return externglib.ConnectGeneratedClosure(self, "changed", false, unsafe.Pointer(C._gotk4_flatpak1_TransactionProgress_ConnectChanged), f)
}

// BytesTransferred gets the number of bytes that have been transferred.
//
// The function returns the following values:
//
//    - guint64: number of bytes transferred.
//
func (self *TransactionProgress) BytesTransferred() uint64 {
	var _arg0 *C.FlatpakTransactionProgress // out
	var _cret C.guint64                     // in

	_arg0 = (*C.FlatpakTransactionProgress)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_progress_get_bytes_transferred(_arg0)
	runtime.KeepAlive(self)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// IsEstimating gets whether the progress is currently estimating.
//
// The function returns the following values:
//
//    - ok: whether we're estimating.
//
func (self *TransactionProgress) IsEstimating() bool {
	var _arg0 *C.FlatpakTransactionProgress // out
	var _cret C.gboolean                    // in

	_arg0 = (*C.FlatpakTransactionProgress)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_progress_get_is_estimating(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Progress gets the current progress.
//
// The function returns the following values:
//
//    - gint: current progress, as an integer between 0 and 100.
//
func (self *TransactionProgress) Progress() int {
	var _arg0 *C.FlatpakTransactionProgress // out
	var _cret C.int                         // in

	_arg0 = (*C.FlatpakTransactionProgress)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_progress_get_progress(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// StartTime gets the time at which this operation has started, as monotonic
// time.
//
// The function returns the following values:
//
//    - guint64: start time.
//
func (self *TransactionProgress) StartTime() uint64 {
	var _arg0 *C.FlatpakTransactionProgress // out
	var _cret C.guint64                     // in

	_arg0 = (*C.FlatpakTransactionProgress)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_progress_get_start_time(_arg0)
	runtime.KeepAlive(self)

	var _guint64 uint64 // out

	_guint64 = uint64(_cret)

	return _guint64
}

// Status gets the current status string.
//
// The function returns the following values:
//
//    - utf8: current status.
//
func (self *TransactionProgress) Status() string {
	var _arg0 *C.FlatpakTransactionProgress // out
	var _cret *C.char                       // in

	_arg0 = (*C.FlatpakTransactionProgress)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_transaction_progress_get_status(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))

	return _utf8
}

// SetUpdateFrequency sets how often progress should be updated.
//
// The function takes the following parameters:
//
//    - updateInterval: update interval, in milliseconds.
//
func (self *TransactionProgress) SetUpdateFrequency(updateInterval uint) {
	var _arg0 *C.FlatpakTransactionProgress // out
	var _arg1 C.guint                       // out

	_arg0 = (*C.FlatpakTransactionProgress)(unsafe.Pointer(externglib.InternObject(self).Native()))
	_arg1 = C.guint(updateInterval)

	C.flatpak_transaction_progress_set_update_frequency(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(updateInterval)
}
