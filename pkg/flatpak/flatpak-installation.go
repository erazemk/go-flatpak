// Code generated by girgen. DO NOT EDIT.

package flatpak

import (
	"context"
	"fmt"
	"runtime"
	"strings"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gbox"
	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	externglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <flatpak.h>
// #include <glib-object.h>
// extern void _gotk4_flatpak1_ProgressCallback(char*, guint, gboolean, gpointer);
import "C"

// glib.Type values for flatpak-installation.go.
var (
	GTypeStorageType    = externglib.Type(C.flatpak_storage_type_get_type())
	GTypeInstallFlags   = externglib.Type(C.flatpak_install_flags_get_type())
	GTypeLaunchFlags    = externglib.Type(C.flatpak_launch_flags_get_type())
	GTypeQueryFlags     = externglib.Type(C.flatpak_query_flags_get_type())
	GTypeUninstallFlags = externglib.Type(C.flatpak_uninstall_flags_get_type())
	GTypeUpdateFlags    = externglib.Type(C.flatpak_update_flags_get_type())
	GTypeInstallation   = externglib.Type(C.flatpak_installation_get_type())
)

func init() {
	externglib.RegisterGValueMarshalers([]externglib.TypeMarshaler{
		{T: GTypeStorageType, F: marshalStorageType},
		{T: GTypeInstallFlags, F: marshalInstallFlags},
		{T: GTypeLaunchFlags, F: marshalLaunchFlags},
		{T: GTypeQueryFlags, F: marshalQueryFlags},
		{T: GTypeUninstallFlags, F: marshalUninstallFlags},
		{T: GTypeUpdateFlags, F: marshalUpdateFlags},
		{T: GTypeInstallation, F: marshalInstallation},
	})
}

// StorageType: information about the storage of an installation.
type StorageType C.gint

const (
	// StorageTypeDefault: default.
	StorageTypeDefault StorageType = iota
	// StorageTypeHardDisk: installation is on a hard disk.
	StorageTypeHardDisk
	// StorageTypeSdcard: installation is on a SD card.
	StorageTypeSdcard
	// StorageTypeMmc: installation is on an MMC.
	StorageTypeMmc
	// StorageTypeNetwork: installation is on the network.
	StorageTypeNetwork
)

func marshalStorageType(p uintptr) (interface{}, error) {
	return StorageType(externglib.ValueFromNative(unsafe.Pointer(p)).Enum()), nil
}

// String returns the name in string for StorageType.
func (s StorageType) String() string {
	switch s {
	case StorageTypeDefault:
		return "Default"
	case StorageTypeHardDisk:
		return "HardDisk"
	case StorageTypeSdcard:
		return "Sdcard"
	case StorageTypeMmc:
		return "Mmc"
	case StorageTypeNetwork:
		return "Network"
	default:
		return fmt.Sprintf("StorageType(%d)", s)
	}
}

// InstallFlags flags to alter the behavior of
// flatpak_installation_install_full().
type InstallFlags C.guint

const (
	// InstallFlagsNone: default.
	InstallFlagsNone InstallFlags = 0b0
	// InstallFlagsNoStaticDeltas: don't use static deltas when pulling.
	InstallFlagsNoStaticDeltas InstallFlags = 0b1
	// InstallFlagsNoDeploy: don't install any new builds that might be fetched.
	InstallFlagsNoDeploy InstallFlags = 0b100
	// InstallFlagsNoPull: don't try to fetch new builds from the remote repo.
	InstallFlagsNoPull InstallFlags = 0b1000
	// InstallFlagsNoTriggers: don't call triggers after installing. If used,
	// the caller must later call flatpak_installation_run_triggers() to update
	// the exported files. (Since: 1.0.3).
	InstallFlagsNoTriggers InstallFlags = 0b10000
)

func marshalInstallFlags(p uintptr) (interface{}, error) {
	return InstallFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for InstallFlags.
func (i InstallFlags) String() string {
	if i == 0 {
		return "InstallFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(106)

	for i != 0 {
		next := i & (i - 1)
		bit := i - next

		switch bit {
		case InstallFlagsNone:
			builder.WriteString("None|")
		case InstallFlagsNoStaticDeltas:
			builder.WriteString("NoStaticDeltas|")
		case InstallFlagsNoDeploy:
			builder.WriteString("NoDeploy|")
		case InstallFlagsNoPull:
			builder.WriteString("NoPull|")
		case InstallFlagsNoTriggers:
			builder.WriteString("NoTriggers|")
		default:
			builder.WriteString(fmt.Sprintf("InstallFlags(0b%b)|", bit))
		}

		i = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if i contains other.
func (i InstallFlags) Has(other InstallFlags) bool {
	return (i & other) == other
}

// LaunchFlags flags to alter the behavior of
// flatpak_installation_launch_full().
type LaunchFlags C.guint

const (
	// LaunchFlagsNone: default.
	LaunchFlagsNone LaunchFlags = 0b0
	// LaunchFlagsDoNotReap: do not reap the child. Use this if you want to wait
	// for the child with g_child_watch_add(). (Since: 1.1).
	LaunchFlagsDoNotReap LaunchFlags = 0b1
)

func marshalLaunchFlags(p uintptr) (interface{}, error) {
	return LaunchFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for LaunchFlags.
func (l LaunchFlags) String() string {
	if l == 0 {
		return "LaunchFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(36)

	for l != 0 {
		next := l & (l - 1)
		bit := l - next

		switch bit {
		case LaunchFlagsNone:
			builder.WriteString("None|")
		case LaunchFlagsDoNotReap:
			builder.WriteString("DoNotReap|")
		default:
			builder.WriteString(fmt.Sprintf("LaunchFlags(0b%b)|", bit))
		}

		l = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if l contains other.
func (l LaunchFlags) Has(other LaunchFlags) bool {
	return (l & other) == other
}

// QueryFlags flags to alter the behavior of e.g
// flatpak_installation_list_remote_refs_sync_full().
type QueryFlags C.guint

const (
	// QueryFlagsNone: default.
	QueryFlagsNone QueryFlags = 0b0
	// QueryFlagsOnlyCached: don't do any network i/o, but only return cached
	// data. This can return stale data, or a ATPAK_ERROR_NOT_CACHED error,
	// however it is a lot more efficient if you're doing many requests.
	QueryFlagsOnlyCached QueryFlags = 0b1
	// QueryFlagsOnlySideloaded: only list refs available from sideload repos;
	// see flatpak(1). (Since: 1.7).
	QueryFlagsOnlySideloaded QueryFlags = 0b10
	// QueryFlagsAllArches: include refs from all arches, not just the primary
	// ones. (Since: 1.11.2).
	QueryFlagsAllArches QueryFlags = 0b100
)

func marshalQueryFlags(p uintptr) (interface{}, error) {
	return QueryFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for QueryFlags.
func (q QueryFlags) String() string {
	if q == 0 {
		return "QueryFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(80)

	for q != 0 {
		next := q & (q - 1)
		bit := q - next

		switch bit {
		case QueryFlagsNone:
			builder.WriteString("None|")
		case QueryFlagsOnlyCached:
			builder.WriteString("OnlyCached|")
		case QueryFlagsOnlySideloaded:
			builder.WriteString("OnlySideloaded|")
		case QueryFlagsAllArches:
			builder.WriteString("AllArches|")
		default:
			builder.WriteString(fmt.Sprintf("QueryFlags(0b%b)|", bit))
		}

		q = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if q contains other.
func (q QueryFlags) Has(other QueryFlags) bool {
	return (q & other) == other
}

// UninstallFlags flags to alter the behavior of
// flatpak_installation_uninstall_full().
type UninstallFlags C.guint

const (
	// UninstallFlagsNone: default.
	UninstallFlagsNone UninstallFlags = 0b0
	// UninstallFlagsNoPrune: don't prune the local OSTree repository after
	// uninstalling.
	UninstallFlagsNoPrune UninstallFlags = 0b1
	// UninstallFlagsNoTriggers: don't call triggers after uninstalling. If
	// used, the caller must later call flatpak_installation_run_triggers() to
	// update the exported file. (Since: 1.0.3).
	UninstallFlagsNoTriggers UninstallFlags = 0b10
)

func marshalUninstallFlags(p uintptr) (interface{}, error) {
	return UninstallFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for UninstallFlags.
func (u UninstallFlags) String() string {
	if u == 0 {
		return "UninstallFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(65)

	for u != 0 {
		next := u & (u - 1)
		bit := u - next

		switch bit {
		case UninstallFlagsNone:
			builder.WriteString("None|")
		case UninstallFlagsNoPrune:
			builder.WriteString("NoPrune|")
		case UninstallFlagsNoTriggers:
			builder.WriteString("NoTriggers|")
		default:
			builder.WriteString(fmt.Sprintf("UninstallFlags(0b%b)|", bit))
		}

		u = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if u contains other.
func (u UninstallFlags) Has(other UninstallFlags) bool {
	return (u & other) == other
}

// UpdateFlags flags to alter the behavior of flatpak_installation_update().
type UpdateFlags C.guint

const (
	// UpdateFlagsNone: fetch remote builds and install the latest one
	// (default).
	UpdateFlagsNone UpdateFlags = 0b0
	// UpdateFlagsNoDeploy: don't install any new builds that might be fetched.
	UpdateFlagsNoDeploy UpdateFlags = 0b1
	// UpdateFlagsNoPull: don't try to fetch new builds from the remote repo.
	UpdateFlagsNoPull UpdateFlags = 0b10
	// UpdateFlagsNoStaticDeltas: don't use static deltas when pulling.
	UpdateFlagsNoStaticDeltas UpdateFlags = 0b100
	// UpdateFlagsNoPrune: don't prune the local OSTree repository after
	// updating (Since: 0.11.8).
	UpdateFlagsNoPrune UpdateFlags = 0b1000
	// UpdateFlagsNoTriggers: don't call triggers after updating. If used, the
	// caller must later call flatpak_installation_run_triggers() to update the
	// exported files. (Since: 1.0.3).
	UpdateFlagsNoTriggers UpdateFlags = 0b10000
)

func marshalUpdateFlags(p uintptr) (interface{}, error) {
	return UpdateFlags(externglib.ValueFromNative(unsafe.Pointer(p)).Flags()), nil
}

// String returns the names in string for UpdateFlags.
func (u UpdateFlags) String() string {
	if u == 0 {
		return "UpdateFlags(0)"
	}

	var builder strings.Builder
	builder.Grow(120)

	for u != 0 {
		next := u & (u - 1)
		bit := u - next

		switch bit {
		case UpdateFlagsNone:
			builder.WriteString("None|")
		case UpdateFlagsNoDeploy:
			builder.WriteString("NoDeploy|")
		case UpdateFlagsNoPull:
			builder.WriteString("NoPull|")
		case UpdateFlagsNoStaticDeltas:
			builder.WriteString("NoStaticDeltas|")
		case UpdateFlagsNoPrune:
			builder.WriteString("NoPrune|")
		case UpdateFlagsNoTriggers:
			builder.WriteString("NoTriggers|")
		default:
			builder.WriteString(fmt.Sprintf("UpdateFlags(0b%b)|", bit))
		}

		u = next
	}

	return strings.TrimSuffix(builder.String(), "|")
}

// Has returns true if u contains other.
func (u UpdateFlags) Has(other UpdateFlags) bool {
	return (u & other) == other
}

// ProgressCallback progress callback is called repeatedly during long-running
// operations such as installations or updates, and can be used to update
// progress information in a user interface.
//
// The callback occurs in the thread-default context of the caller.
type ProgressCallback func(status string, progress uint, estimating bool)

//export _gotk4_flatpak1_ProgressCallback
func _gotk4_flatpak1_ProgressCallback(arg1 *C.char, arg2 C.guint, arg3 C.gboolean, arg4 C.gpointer) {
	var fn ProgressCallback
	{
		v := gbox.Get(uintptr(arg4))
		if v == nil {
			panic(`callback not found`)
		}
		fn = v.(ProgressCallback)
	}

	var _status string   // out
	var _progress uint   // out
	var _estimating bool // out

	_status = C.GoString((*C.gchar)(unsafe.Pointer(arg1)))
	_progress = uint(arg2)
	if arg3 != 0 {
		_estimating = true
	}

	fn(_status, _progress, _estimating)
}

// GetDefaultArch returns the canonical name for the arch of the current
// machine.
//
// The function returns the following values:
//
//    - utf8: arch string.
//
func GetDefaultArch() string {
	var _cret *C.char // in

	_cret = C.flatpak_get_default_arch()

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// GetSupportedArches returns the canonical names for the arches that are
// supported (i.e. can run) on the current machine, in order of priority
// (default is first).
//
// The function returns the following values:
//
//    - utf8s: zero terminated array of arch strings.
//
func GetSupportedArches() []string {
	var _cret **C.char // in

	_cret = C.flatpak_get_supported_arches()

	var _utf8s []string // out

	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
		}
	}

	return _utf8s
}

// InstallationOverrider contains methods that are overridable.
type InstallationOverrider interface {
}

type Installation struct {
	_ [0]func() // equal guard
	*externglib.Object
}

var (
	_ externglib.Objector = (*Installation)(nil)
)

func classInitInstallationer(gclassPtr, data C.gpointer) {
	C.g_type_class_add_private(gclassPtr, C.gsize(unsafe.Sizeof(uintptr(0))))

	goffset := C.g_type_class_get_instance_private_offset(gclassPtr)
	*(*C.gpointer)(unsafe.Add(unsafe.Pointer(gclassPtr), goffset)) = data

}

func wrapInstallation(obj *externglib.Object) *Installation {
	return &Installation{
		Object: obj,
	}
}

func marshalInstallation(p uintptr) (interface{}, error) {
	return wrapInstallation(externglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewInstallationForPath creates a new Installation for the installation at the
// given path.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - path: #GFile.
//    - user: whether this is a user-specific location.
//
// The function returns the following values:
//
//    - installation: new Installation.
//
func NewInstallationForPath(ctx context.Context, path gio.Filer, user bool) (*Installation, error) {
	var _arg3 *C.GCancellable        // out
	var _arg1 *C.GFile               // out
	var _arg2 C.gboolean             // out
	var _cret *C.FlatpakInstallation // in
	var _cerr *C.GError              // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GFile)(unsafe.Pointer(externglib.InternObject(path).Native()))
	if user {
		_arg2 = C.TRUE
	}

	_cret = C.flatpak_installation_new_for_path(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(path)
	runtime.KeepAlive(user)

	var _installation *Installation // out
	var _goerr error                // out

	_installation = wrapInstallation(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _installation, _goerr
}

// NewInstallationSystem creates a new Installation for the default system-wide
// installation.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//
// The function returns the following values:
//
//    - installation: new Installation.
//
func NewInstallationSystem(ctx context.Context) (*Installation, error) {
	var _arg1 *C.GCancellable        // out
	var _cret *C.FlatpakInstallation // in
	var _cerr *C.GError              // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.flatpak_installation_new_system(_arg1, &_cerr)
	runtime.KeepAlive(ctx)

	var _installation *Installation // out
	var _goerr error                // out

	_installation = wrapInstallation(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _installation, _goerr
}

// NewInstallationSystemWithID creates a new Installation for the system-wide
// installation id.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - id (optional): ID of the system-wide installation.
//
// The function returns the following values:
//
//    - installation: new Installation.
//
func NewInstallationSystemWithID(ctx context.Context, id string) (*Installation, error) {
	var _arg2 *C.GCancellable        // out
	var _arg1 *C.char                // out
	var _cret *C.FlatpakInstallation // in
	var _cerr *C.GError              // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	if id != "" {
		_arg1 = (*C.char)(unsafe.Pointer(C.CString(id)))
		defer C.free(unsafe.Pointer(_arg1))
	}

	_cret = C.flatpak_installation_new_system_with_id(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(id)

	var _installation *Installation // out
	var _goerr error                // out

	_installation = wrapInstallation(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _installation, _goerr
}

// NewInstallationUser creates a new Installation for the per-user installation.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//
// The function returns the following values:
//
//    - installation: new Installation.
//
func NewInstallationUser(ctx context.Context) (*Installation, error) {
	var _arg1 *C.GCancellable        // out
	var _cret *C.FlatpakInstallation // in
	var _cerr *C.GError              // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.flatpak_installation_new_user(_arg1, &_cerr)
	runtime.KeepAlive(ctx)

	var _installation *Installation // out
	var _goerr error                // out

	_installation = wrapInstallation(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _installation, _goerr
}

// AddRemote adds a new remote object to the set of remotes. This is similar to
// flatpak_installation_modify_remote() for non-existing remote names. However,
// if the named remote already exists then instead of modifying it it fails with
// FLATPAK_ERROR_ALREADY_INSTALLED, or if if_needed is true it silently succeeds
// without doing anything.
//
// As an exception to the last, if the local config has a filter defined, but
// the new remote unsets the filter (for example, it comes from an unfiltered
// .flatpakref via flatpak_remote_new_from_file()) the the local remote filter
// gets reset. This is to allow the setup where there is a default setup of a
// filtered remote, yet you can still use the standard flatpakref file to get
// the full contents without getting two remotes.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - remote: new Remote.
//    - ifNeeded: if TRUE, only add if it doesn't exists.
//
func (self *Installation) AddRemote(ctx context.Context, remote *Remote, ifNeeded bool) error {
	var _arg0 *C.FlatpakInstallation // out
	var _arg3 *C.GCancellable        // out
	var _arg1 *C.FlatpakRemote       // out
	var _arg2 C.gboolean             // out
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.FlatpakRemote)(unsafe.Pointer(externglib.InternObject(remote).Native()))
	if ifNeeded {
		_arg2 = C.TRUE
	}

	C.flatpak_installation_add_remote(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(remote)
	runtime.KeepAlive(ifNeeded)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CleanupLocalRefsSync: remove all OSTree refs from the local flatpak
// repository which are not in a deployed state. The next time the underlying
// OSTree repo is pruned, objects which were attached to that ref will be
// removed. This is useful if you pulled a flatpak refs using
// flatpak_installation_install_full() and specified
// FLATPAK_INSTALL_FLAGS_NO_DEPLOY but then decided not to deploy the refs later
// on and want to remove the local refs to prevent them from taking up disk
// space. Note that this will not remove the objects referred to by ref from the
// underlying OSTree repo, you should use
// flatpak_installation_prune_local_repo() to do that.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//
func (self *Installation) CleanupLocalRefsSync(ctx context.Context) error {
	var _arg0 *C.FlatpakInstallation // out
	var _arg1 *C.GCancellable        // out
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.flatpak_installation_cleanup_local_refs_sync(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// CreateMonitor gets monitor object for the installation. The returned file
// monitor will emit the Monitor::changed signal whenever an application or
// runtime was installed, uninstalled or updated.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//
// The function returns the following values:
//
//    - fileMonitor: new Monitor instance, or NULL on error.
//
func (self *Installation) CreateMonitor(ctx context.Context) (gio.FileMonitorrer, error) {
	var _arg0 *C.FlatpakInstallation // out
	var _arg1 *C.GCancellable        // out
	var _cret *C.GFileMonitor        // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	_cret = C.flatpak_installation_create_monitor(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)

	var _fileMonitor gio.FileMonitorrer // out
	var _goerr error                    // out

	{
		objptr := unsafe.Pointer(_cret)
		if objptr == nil {
			panic("object of type gio.FileMonitorrer is nil")
		}

		object := externglib.AssumeOwnership(objptr)
		casted := object.WalkCast(func(obj externglib.Objector) bool {
			_, ok := obj.(gio.FileMonitorrer)
			return ok
		})
		rv, ok := casted.(gio.FileMonitorrer)
		if !ok {
			panic("no marshaler for " + object.TypeFromInstance().String() + " matching gio.FileMonitorrer")
		}
		_fileMonitor = rv
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _fileMonitor, _goerr
}

// DropCaches drops all internal (in-memory) caches. For instance, this may be
// needed to pick up new or changed remotes configured outside this installation
// instance.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//
func (self *Installation) DropCaches(ctx context.Context) error {
	var _arg0 *C.FlatpakInstallation // out
	var _arg1 *C.GCancellable        // out
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.flatpak_installation_drop_caches(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// FetchRemoteMetadataSync obtains the metadata file from a commit.
//
// NOTE: Since 0.11.4 this information is accessible in FlatpakRemoteRef, so
// this function is not very useful anymore.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - remoteName: name of the remote.
//    - ref: ref.
//
// The function returns the following values:
//
//    - bytes containing the flatpak metadata file, or NULL if an error occurred.
//
func (self *Installation) FetchRemoteMetadataSync(ctx context.Context, remoteName string, ref *Ref) (*glib.Bytes, error) {
	var _arg0 *C.FlatpakInstallation // out
	var _arg3 *C.GCancellable        // out
	var _arg1 *C.char                // out
	var _arg2 *C.FlatpakRef          // out
	var _cret *C.GBytes              // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(remoteName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.FlatpakRef)(unsafe.Pointer(externglib.InternObject(ref).Native()))

	_cret = C.flatpak_installation_fetch_remote_metadata_sync(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(remoteName)
	runtime.KeepAlive(ref)

	var _bytes *glib.Bytes // out
	var _goerr error       // out

	_bytes = (*glib.Bytes)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_bytes)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.g_bytes_unref((*C.GBytes)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _bytes, _goerr
}

// FetchRemoteRefSync gets the current remote branch of a ref in the remote.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - remoteName: name of the remote.
//    - kind: what this ref contains (an RefKind).
//    - name of the app/runtime to fetch.
//    - arch (optional): which architecture to fetch (default: current
//      architecture).
//    - branch (optional): which branch to fetch (default: 'master').
//
// The function returns the following values:
//
//    - remoteRef instance, or NULL.
//
func (self *Installation) FetchRemoteRefSync(ctx context.Context, remoteName string, kind RefKind, name, arch, branch string) (*RemoteRef, error) {
	var _arg0 *C.FlatpakInstallation // out
	var _arg6 *C.GCancellable        // out
	var _arg1 *C.char                // out
	var _arg2 C.FlatpakRefKind       // out
	var _arg3 *C.char                // out
	var _arg4 *C.char                // out
	var _arg5 *C.char                // out
	var _cret *C.FlatpakRemoteRef    // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg6 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(remoteName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.FlatpakRefKind(kind)
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))
	if arch != "" {
		_arg4 = (*C.char)(unsafe.Pointer(C.CString(arch)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if branch != "" {
		_arg5 = (*C.char)(unsafe.Pointer(C.CString(branch)))
		defer C.free(unsafe.Pointer(_arg5))
	}

	_cret = C.flatpak_installation_fetch_remote_ref_sync(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(remoteName)
	runtime.KeepAlive(kind)
	runtime.KeepAlive(name)
	runtime.KeepAlive(arch)
	runtime.KeepAlive(branch)

	var _remoteRef *RemoteRef // out
	var _goerr error          // out

	_remoteRef = wrapRemoteRef(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _remoteRef, _goerr
}

// FetchRemoteRefSyncFull gets the current remote branch of a ref in the remote.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - remoteName: name of the remote.
//    - kind: what this ref contains (an RefKind).
//    - name of the app/runtime to fetch.
//    - arch (optional): which architecture to fetch (default: current
//      architecture).
//    - branch (optional): which branch to fetch (default: 'master').
//    - flags: set of QueryFlags.
//
// The function returns the following values:
//
//    - remoteRef instance, or NULL.
//
func (self *Installation) FetchRemoteRefSyncFull(ctx context.Context, remoteName string, kind RefKind, name, arch, branch string, flags QueryFlags) (*RemoteRef, error) {
	var _arg0 *C.FlatpakInstallation // out
	var _arg7 *C.GCancellable        // out
	var _arg1 *C.char                // out
	var _arg2 C.FlatpakRefKind       // out
	var _arg3 *C.char                // out
	var _arg4 *C.char                // out
	var _arg5 *C.char                // out
	var _arg6 C.FlatpakQueryFlags    // out
	var _cret *C.FlatpakRemoteRef    // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(remoteName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.FlatpakRefKind(kind)
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))
	if arch != "" {
		_arg4 = (*C.char)(unsafe.Pointer(C.CString(arch)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if branch != "" {
		_arg5 = (*C.char)(unsafe.Pointer(C.CString(branch)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	_arg6 = C.FlatpakQueryFlags(flags)

	_cret = C.flatpak_installation_fetch_remote_ref_sync_full(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(remoteName)
	runtime.KeepAlive(kind)
	runtime.KeepAlive(name)
	runtime.KeepAlive(arch)
	runtime.KeepAlive(branch)
	runtime.KeepAlive(flags)

	var _remoteRef *RemoteRef // out
	var _goerr error          // out

	_remoteRef = wrapRemoteRef(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _remoteRef, _goerr
}

// FetchRemoteSizeSync gets information about the maximum amount of data that
// needs to be transferred to pull the ref from a remote repository, and about
// the amount of local disk space that is required to check out this commit.
//
// Note that if there are locally available data that are in the ref, which is
// common for instance if you're doing an update then the real download size may
// be smaller than what is returned here.
//
// NOTE: Since 0.11.4 this information is accessible in FlatpakRemoteRef, so
// this function is not very useful anymore.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - remoteName: name of the remote.
//    - ref: ref.
//
// The function returns the following values:
//
//    - downloadSize: return location for the (maximum) download size.
//    - installedSize: return location for the installed size.
//
func (self *Installation) FetchRemoteSizeSync(ctx context.Context, remoteName string, ref *Ref) (downloadSize uint64, installedSize uint64, goerr error) {
	var _arg0 *C.FlatpakInstallation // out
	var _arg5 *C.GCancellable        // out
	var _arg1 *C.char                // out
	var _arg2 *C.FlatpakRef          // out
	var _arg3 C.guint64              // in
	var _arg4 C.guint64              // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(remoteName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.FlatpakRef)(unsafe.Pointer(externglib.InternObject(ref).Native()))

	C.flatpak_installation_fetch_remote_size_sync(_arg0, _arg1, _arg2, &_arg3, &_arg4, _arg5, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(remoteName)
	runtime.KeepAlive(ref)

	var _downloadSize uint64  // out
	var _installedSize uint64 // out
	var _goerr error          // out

	_downloadSize = uint64(_arg3)
	_installedSize = uint64(_arg4)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _downloadSize, _installedSize, _goerr
}

// Config: get a global configuration option for the installation, see
// flatpak_installation_set_config_sync() for supported keys.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - key: name of the key to get.
//
// The function returns the following values:
//
//    - utf8: (newly allocated) value, or NULL on error
//      (G_KEY_FILE_ERROR_KEY_NOT_FOUND error if key is not set).
//
func (self *Installation) Config(ctx context.Context, key string) (string, error) {
	var _arg0 *C.FlatpakInstallation // out
	var _arg2 *C.GCancellable        // out
	var _arg1 *C.char                // out
	var _cret *C.char                // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.flatpak_installation_get_config(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(key)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// CurrentInstalledApp: get the last build of reference name that was installed
// with flatpak_installation_install(), or NULL if the reference has never been
// installed locally.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - name of the app.
//
// The function returns the following values:
//
//    - installedRef: InstalledRef.
//
func (self *Installation) CurrentInstalledApp(ctx context.Context, name string) (*InstalledRef, error) {
	var _arg0 *C.FlatpakInstallation // out
	var _arg2 *C.GCancellable        // out
	var _arg1 *C.char                // out
	var _cret *C.FlatpakInstalledRef // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.flatpak_installation_get_current_installed_app(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(name)

	var _installedRef *InstalledRef // out
	var _goerr error                // out

	_installedRef = wrapInstalledRef(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _installedRef, _goerr
}

// DefaultLanguages: get the default languages used by the installation to
// decide which subpaths to install of locale extensions. This list may also be
// used by frontends like GNOME Software to decide which language-specific apps
// to display. An empty array means that all languages should be installed.
//
// The function returns the following values:
//
//    - utf8s: A possibly empty array of strings, or NULL on error.
//
func (self *Installation) DefaultLanguages() ([]string, error) {
	var _arg0 *C.FlatpakInstallation // out
	var _cret **C.char               // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_installation_get_default_languages(_arg0, &_cerr)
	runtime.KeepAlive(self)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// DefaultLocales: like flatpak_installation_get_default_languages() but
// includes territory information (e.g. en_US rather than en) which may be
// included in the extra-languages configuration.
//
// Strings returned by this function are in the format specified by setlocale()
// (man:setlocale): language[_territory][.codeset][modifier].
//
// The function returns the following values:
//
//    - utf8s: A possibly empty array of locale strings, or NULL on error.
//
func (self *Installation) DefaultLocales() ([]string, error) {
	var _arg0 *C.FlatpakInstallation // out
	var _cret **C.char               // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_installation_get_default_locales(_arg0, &_cerr)
	runtime.KeepAlive(self)

	var _utf8s []string // out
	var _goerr error    // out

	defer C.free(unsafe.Pointer(_cret))
	{
		var i int
		var z *C.char
		for p := _cret; *p != z; p = &unsafe.Slice(p, 2)[1] {
			i++
		}

		src := unsafe.Slice(_cret, i)
		_utf8s = make([]string, i)
		for i := range src {
			_utf8s[i] = C.GoString((*C.gchar)(unsafe.Pointer(src[i])))
			defer C.free(unsafe.Pointer(src[i]))
		}
	}
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8s, _goerr
}

// DisplayName returns the display name of the installation for self.
//
// Note that this function may return NULL if the installation does not have a
// display name.
//
// The function returns the following values:
//
//    - utf8: string with the installation's display name.
//
func (self *Installation) DisplayName() string {
	var _arg0 *C.FlatpakInstallation // out
	var _cret *C.char                // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_installation_get_display_name(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// ID returns the ID of the installation for self.
//
// The ID for the default system installation is "default". The ID for the user
// installation is "user".
//
// The function returns the following values:
//
//    - utf8: string with the installation's ID.
//
func (self *Installation) ID() string {
	var _arg0 *C.FlatpakInstallation // out
	var _cret *C.char                // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_installation_get_id(_arg0)
	runtime.KeepAlive(self)

	var _utf8 string // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))

	return _utf8
}

// IsUser returns whether the installation is for a user-specific location.
//
// The function returns the following values:
//
//    - ok: TRUE if self is a per-user installation.
//
func (self *Installation) IsUser() bool {
	var _arg0 *C.FlatpakInstallation // out
	var _cret C.gboolean             // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_installation_get_is_user(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// MinFreeSpaceBytes returns the min-free-space config value from the OSTree
// repository of this installation.
//
// Applications can use this value, together with information about the
// available disk space and the size of pending updates or installs, to estimate
// whether a pull operation will fail due to running out of disk space.
//
// The function returns the following values:
//
//    - outBytes: location to store the result.
//
func (self *Installation) MinFreeSpaceBytes() (uint64, error) {
	var _arg0 *C.FlatpakInstallation // out
	var _arg1 C.guint64              // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	C.flatpak_installation_get_min_free_space_bytes(_arg0, &_arg1, &_cerr)
	runtime.KeepAlive(self)

	var _outBytes uint64 // out
	var _goerr error     // out

	_outBytes = uint64(_arg1)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _outBytes, _goerr
}

// NoInteraction returns the value set with
// flatpak_installation_set_no_interaction().
//
// The function returns the following values:
//
//    - ok: TRUE if interactive authorization dialogs are not allowed.
//
func (self *Installation) NoInteraction() bool {
	var _arg0 *C.FlatpakInstallation // out
	var _cret C.gboolean             // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_installation_get_no_interaction(_arg0)
	runtime.KeepAlive(self)

	var _ok bool // out

	if _cret != 0 {
		_ok = true
	}

	return _ok
}

// Path returns the installation location for self.
//
// The function returns the following values:
//
//    - file: #GFile.
//
func (self *Installation) Path() *gio.File {
	var _arg0 *C.FlatpakInstallation // out
	var _cret *C.GFile               // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_installation_get_path(_arg0)
	runtime.KeepAlive(self)

	var _file *gio.File // out

	{
		obj := externglib.AssumeOwnership(unsafe.Pointer(_cret))
		_file = &gio.File{
			Object: obj,
		}
	}

	return _file
}

// Priority returns the numeric priority of the installation for self.
//
// The function returns the following values:
//
//    - gint: integer with the configured priority value.
//
func (self *Installation) Priority() int {
	var _arg0 *C.FlatpakInstallation // out
	var _cret C.gint                 // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_installation_get_priority(_arg0)
	runtime.KeepAlive(self)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// RemoteByName looks up a remote by name.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - name: remote name.
//
// The function returns the following values:
//
//    - remote instance, or NULL with error set.
//
func (self *Installation) RemoteByName(ctx context.Context, name string) (*Remote, error) {
	var _arg0 *C.FlatpakInstallation // out
	var _arg2 *C.GCancellable        // out
	var _arg1 *C.gchar               // out
	var _cret *C.FlatpakRemote       // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.gchar)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.flatpak_installation_get_remote_by_name(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(name)

	var _remote *Remote // out
	var _goerr error    // out

	_remote = wrapRemote(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _remote, _goerr
}

// StorageType returns the type of storage of the installation for self.
//
// The function returns the following values:
//
//    - storageType: StorageType.
//
func (self *Installation) StorageType() StorageType {
	var _arg0 *C.FlatpakInstallation // out
	var _cret C.FlatpakStorageType   // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))

	_cret = C.flatpak_installation_get_storage_type(_arg0)
	runtime.KeepAlive(self)

	var _storageType StorageType // out

	_storageType = StorageType(_cret)

	return _storageType
}

// Install: this is an old deprecated function, you should use Transaction and
// flatpak_transaction_add_install() instead. It has a lot more interesting
// features.
//
// Install a new application or runtime.
//
// Note that this function was originally written to always return a
// InstalledRef. Since 0.9.13, passing FLATPAK_INSTALL_FLAGS_NO_DEPLOY will only
// pull refs into the local flatpak repository without deploying them, however
// this function will be unable to provide information on the installed ref, so
// FLATPAK_ERROR_ONLY_PULLED will be set and the caller must respond
// accordingly.
//
// Deprecated: Use flatpak_transaction_add_install() instead.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - remoteName: name of the remote to use.
//    - kind: what this ref contains (an RefKind).
//    - name of the app/runtime to fetch.
//    - arch (optional): which architecture to fetch (default: current
//      architecture).
//    - branch (optional): which branch to fetch (default: 'master').
//    - progress (optional) callback.
//
// The function returns the following values:
//
//    - installedRef: ref for the newly installed app or NULL on failure.
//
func (self *Installation) Install(ctx context.Context, remoteName string, kind RefKind, name, arch, branch string, progress ProgressCallback) (*InstalledRef, error) {
	var _arg0 *C.FlatpakInstallation    // out
	var _arg8 *C.GCancellable           // out
	var _arg1 *C.char                   // out
	var _arg2 C.FlatpakRefKind          // out
	var _arg3 *C.char                   // out
	var _arg4 *C.char                   // out
	var _arg5 *C.char                   // out
	var _arg6 C.FlatpakProgressCallback // out
	var _arg7 C.gpointer
	var _cret *C.FlatpakInstalledRef // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg8 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(remoteName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.FlatpakRefKind(kind)
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))
	if arch != "" {
		_arg4 = (*C.char)(unsafe.Pointer(C.CString(arch)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if branch != "" {
		_arg5 = (*C.char)(unsafe.Pointer(C.CString(branch)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if progress != nil {
		_arg6 = (*[0]byte)(C._gotk4_flatpak1_ProgressCallback)
		_arg7 = C.gpointer(gbox.Assign(progress))
		defer gbox.Delete(uintptr(_arg7))
	}

	_cret = C.flatpak_installation_install(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(remoteName)
	runtime.KeepAlive(kind)
	runtime.KeepAlive(name)
	runtime.KeepAlive(arch)
	runtime.KeepAlive(branch)
	runtime.KeepAlive(progress)

	var _installedRef *InstalledRef // out
	var _goerr error                // out

	_installedRef = wrapInstalledRef(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _installedRef, _goerr
}

// InstallBundle: this is an old deprecated function, you should use Transaction
// and flatpak_transaction_add_install_bundle() instead. It has a lot more
// interesting features.
//
// Install an application or runtime from an flatpak bundle file. See
// flatpak-build-bundle(1) for how to create bundles.
//
// Deprecated: Use flatpak_transaction_add_install_bundle() instead.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - file that is an flatpak bundle.
//    - progress (optional) callback.
//
// The function returns the following values:
//
//    - installedRef: ref for the newly installed app or NULL on failure.
//
func (self *Installation) InstallBundle(ctx context.Context, file gio.Filer, progress ProgressCallback) (*InstalledRef, error) {
	var _arg0 *C.FlatpakInstallation    // out
	var _arg4 *C.GCancellable           // out
	var _arg1 *C.GFile                  // out
	var _arg2 C.FlatpakProgressCallback // out
	var _arg3 C.gpointer
	var _cret *C.FlatpakInstalledRef // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg4 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GFile)(unsafe.Pointer(externglib.InternObject(file).Native()))
	if progress != nil {
		_arg2 = (*[0]byte)(C._gotk4_flatpak1_ProgressCallback)
		_arg3 = C.gpointer(gbox.Assign(progress))
		defer gbox.Delete(uintptr(_arg3))
	}

	_cret = C.flatpak_installation_install_bundle(_arg0, _arg1, _arg2, _arg3, _arg4, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(file)
	runtime.KeepAlive(progress)

	var _installedRef *InstalledRef // out
	var _goerr error                // out

	_installedRef = wrapInstalledRef(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _installedRef, _goerr
}

// InstallFull: this is an old deprecated function, you should use Transaction
// and flatpak_transaction_add_install() instead. It has a lot more interesting
// features.
//
// Install a new application or runtime.
//
// Note that this function was originally written to always return a
// InstalledRef. Since 0.9.13, passing FLATPAK_INSTALL_FLAGS_NO_DEPLOY will only
// pull refs into the local flatpak repository without deploying them, however
// this function will be unable to provide information on the installed ref, so
// FLATPAK_ERROR_ONLY_PULLED will be set and the caller must respond
// accordingly.
//
// Deprecated: Use flatpak_transaction_add_install() instead.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - flags: set of InstallFlags flag.
//    - remoteName: name of the remote to use.
//    - kind: what this ref contains (an RefKind).
//    - name of the app/runtime to fetch.
//    - arch (optional): which architecture to fetch (default: current
//      architecture).
//    - branch (optional): which branch to fetch (default: 'master').
//    - subpaths (optional): list of subpaths to fetch, or NULL for everything.
//    - progress (optional) callback.
//
// The function returns the following values:
//
//    - installedRef: ref for the newly installed app or NULL on failure.
//
func (self *Installation) InstallFull(ctx context.Context, flags InstallFlags, remoteName string, kind RefKind, name, arch, branch string, subpaths []string, progress ProgressCallback) (*InstalledRef, error) {
	var _arg0 *C.FlatpakInstallation    // out
	var _arg10 *C.GCancellable          // out
	var _arg1 C.FlatpakInstallFlags     // out
	var _arg2 *C.char                   // out
	var _arg3 C.FlatpakRefKind          // out
	var _arg4 *C.char                   // out
	var _arg5 *C.char                   // out
	var _arg6 *C.char                   // out
	var _arg7 **C.char                  // out
	var _arg8 C.FlatpakProgressCallback // out
	var _arg9 C.gpointer
	var _cret *C.FlatpakInstalledRef // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg10 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.FlatpakInstallFlags(flags)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(remoteName)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.FlatpakRefKind(kind)
	_arg4 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg4))
	if arch != "" {
		_arg5 = (*C.char)(unsafe.Pointer(C.CString(arch)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if branch != "" {
		_arg6 = (*C.char)(unsafe.Pointer(C.CString(branch)))
		defer C.free(unsafe.Pointer(_arg6))
	}
	{
		_arg7 = (**C.char)(C.calloc(C.size_t((len(subpaths) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg7))
		{
			out := unsafe.Slice(_arg7, len(subpaths)+1)
			var zero *C.char
			out[len(subpaths)] = zero
			for i := range subpaths {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(subpaths[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	if progress != nil {
		_arg8 = (*[0]byte)(C._gotk4_flatpak1_ProgressCallback)
		_arg9 = C.gpointer(gbox.Assign(progress))
		defer gbox.Delete(uintptr(_arg9))
	}

	_cret = C.flatpak_installation_install_full(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, _arg10, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(remoteName)
	runtime.KeepAlive(kind)
	runtime.KeepAlive(name)
	runtime.KeepAlive(arch)
	runtime.KeepAlive(branch)
	runtime.KeepAlive(subpaths)
	runtime.KeepAlive(progress)

	var _installedRef *InstalledRef // out
	var _goerr error                // out

	_installedRef = wrapInstalledRef(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _installedRef, _goerr
}

// InstallRefFile: this is an old deprecated function, you should use
// Transaction and flatpak_transaction_add_install_flatpakref() instead. It has
// a lot more interesting features.
//
// Creates a remote based on the passed in .flatpakref file contents in
// ref_file_data and returns the RemoteRef that can be used to install it.
//
// Note, the RemoteRef will not have the commit field set, or other details, to
// avoid unnecessary roundtrips. If you need that you have to resolve it
// explicitly with flatpak_installation_fetch_remote_ref_sync ().
//
// Deprecated: Use flatpak_transaction_add_install_flatpakref() instead.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - refFileData: ref file contents.
//
// The function returns the following values:
//
//    - remoteRef if the remote has been added successfully, NULL on error.
//
func (self *Installation) InstallRefFile(ctx context.Context, refFileData *glib.Bytes) (*RemoteRef, error) {
	var _arg0 *C.FlatpakInstallation // out
	var _arg2 *C.GCancellable        // out
	var _arg1 *C.GBytes              // out
	var _cret *C.FlatpakRemoteRef    // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.GBytes)(gextras.StructNative(unsafe.Pointer(refFileData)))

	_cret = C.flatpak_installation_install_ref_file(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(refFileData)

	var _remoteRef *RemoteRef // out
	var _goerr error          // out

	_remoteRef = wrapRemoteRef(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _remoteRef, _goerr
}

// Launch an installed application.
//
// You can use flatpak_installation_get_installed_ref() or
// flatpak_installation_get_current_installed_app() to find out what builds are
// available, in order to get a value for commit.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - name of the app to launch.
//    - arch (optional): which architecture to launch (default: current
//      architecture).
//    - branch (optional): which branch of the application (default: "master").
//    - commit (optional) of branch to launch.
//
func (self *Installation) Launch(ctx context.Context, name, arch, branch, commit string) error {
	var _arg0 *C.FlatpakInstallation // out
	var _arg5 *C.GCancellable        // out
	var _arg1 *C.char                // out
	var _arg2 *C.char                // out
	var _arg3 *C.char                // out
	var _arg4 *C.char                // out
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg5 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))
	if arch != "" {
		_arg2 = (*C.char)(unsafe.Pointer(C.CString(arch)))
		defer C.free(unsafe.Pointer(_arg2))
	}
	if branch != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(branch)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if commit != "" {
		_arg4 = (*C.char)(unsafe.Pointer(C.CString(commit)))
		defer C.free(unsafe.Pointer(_arg4))
	}

	C.flatpak_installation_launch(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(name)
	runtime.KeepAlive(arch)
	runtime.KeepAlive(branch)
	runtime.KeepAlive(commit)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// LoadAppOverrides loads the metadata overrides file for an application.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - appId: application id.
//
// The function returns the following values:
//
//    - utf8 contents of the overrides files, or NULL if an error occurred.
//
func (self *Installation) LoadAppOverrides(ctx context.Context, appId string) (string, error) {
	var _arg0 *C.FlatpakInstallation // out
	var _arg2 *C.GCancellable        // out
	var _arg1 *C.char                // out
	var _cret *C.char                // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(appId)))
	defer C.free(unsafe.Pointer(_arg1))

	_cret = C.flatpak_installation_load_app_overrides(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(appId)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}

// ModifyRemote saves changes in the remote object.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - remote: modified Remote.
//
func (self *Installation) ModifyRemote(ctx context.Context, remote *Remote) error {
	var _arg0 *C.FlatpakInstallation // out
	var _arg2 *C.GCancellable        // out
	var _arg1 *C.FlatpakRemote       // out
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.FlatpakRemote)(unsafe.Pointer(externglib.InternObject(remote).Native()))

	C.flatpak_installation_modify_remote(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(remote)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// PruneLocalRepo: remove all orphaned OSTree objects from the underlying OSTree
// repo in self.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//
func (self *Installation) PruneLocalRepo(ctx context.Context) error {
	var _arg0 *C.FlatpakInstallation // out
	var _arg1 *C.GCancellable        // out
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.flatpak_installation_prune_local_repo(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveLocalRefSync: remove the OSTree ref given by remote_name:ref from the
// local flatpak repository. The next time the underlying OSTree repo is pruned,
// objects which were attached to that ref will be removed. This is useful if
// you pulled a flatpak ref using flatpak_installation_install_full() and
// specified FLATPAK_INSTALL_FLAGS_NO_DEPLOY but then decided not to deploy the
// ref later on and want to remove the local ref to prevent it from taking up
// disk space. Note that this will not remove the objects referred to by ref
// from the underlying OSTree repo, you should use
// flatpak_installation_prune_local_repo() to do that.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - remoteName: name of the remote.
//    - ref: ref.
//
func (self *Installation) RemoveLocalRefSync(ctx context.Context, remoteName, ref string) error {
	var _arg0 *C.FlatpakInstallation // out
	var _arg3 *C.GCancellable        // out
	var _arg1 *C.char                // out
	var _arg2 *C.char                // out
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(remoteName)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(ref)))
	defer C.free(unsafe.Pointer(_arg2))

	C.flatpak_installation_remove_local_ref_sync(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(remoteName)
	runtime.KeepAlive(ref)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RemoveRemote removes the remote with the given name from the installation.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - name of the remote to remove.
//
func (self *Installation) RemoveRemote(ctx context.Context, name string) error {
	var _arg0 *C.FlatpakInstallation // out
	var _arg2 *C.GCancellable        // out
	var _arg1 *C.char                // out
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.flatpak_installation_remove_remote(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(name)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// RunTriggers: run the trigger commands to update the files exported by the
// apps in self. Should be used after one or more app install, upgrade or
// uninstall operations with the FLATPAK_INSTALL_FLAGS_NO_TRIGGERS,
// FLATPAK_UPDATE_FLAGS_NO_TRIGGERS or FLATPAK_UNINSTALL_FLAGS_NO_TRIGGERS flags
// set.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//
func (self *Installation) RunTriggers(ctx context.Context) error {
	var _arg0 *C.FlatpakInstallation // out
	var _arg1 *C.GCancellable        // out
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg1 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}

	C.flatpak_installation_run_triggers(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetConfigSync: set a global configuration option for the installation,
// currently the only supported keys are languages, which is a
// semicolon-separated list of language codes like "sv;en;pl", or "" to mean all
// languages, and extra-languages, which is a semicolon-separated list of locale
// identifiers like "en;en_DK;zh_HK.big5hkscs;uz_UZ.utf8cyrillic".
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - key: name of the key to set.
//    - value: new value, or NULL to unset.
//
func (self *Installation) SetConfigSync(ctx context.Context, key, value string) error {
	var _arg0 *C.FlatpakInstallation // out
	var _arg3 *C.GCancellable        // out
	var _arg1 *C.char                // out
	var _arg2 *C.char                // out
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg3 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(key)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(value)))
	defer C.free(unsafe.Pointer(_arg2))

	C.flatpak_installation_set_config_sync(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(key)
	runtime.KeepAlive(value)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetNoInteraction: this method can be used to prevent interactive
// authorization dialogs to appear for operations on self. This is useful for
// background operations that are not directly triggered by a user action.
//
// By default, interaction is allowed.
//
// The function takes the following parameters:
//
//    - noInteraction: whether to disallow interactive authorization for
//      operations.
//
func (self *Installation) SetNoInteraction(noInteraction bool) {
	var _arg0 *C.FlatpakInstallation // out
	var _arg1 C.gboolean             // out

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	if noInteraction {
		_arg1 = C.TRUE
	}

	C.flatpak_installation_set_no_interaction(_arg0, _arg1)
	runtime.KeepAlive(self)
	runtime.KeepAlive(noInteraction)
}

// Uninstall: this is an old deprecated function, you should use Transaction and
// flatpak_transaction_add_uninstall() instead. It has a lot more interesting
// features.
//
// Uninstall an application or runtime.
//
// Deprecated: Use flatpak_transaction_add_uninstall() instead.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - kind: what this ref contains (an RefKind).
//    - name of the app or runtime to uninstall.
//    - arch (optional): architecture of the app or runtime to uninstall; if
//      NULL, flatpak_get_default_arch() is assumed.
//    - branch (optional): name of the branch of the app or runtime to uninstall;
//      if NULL, master is assumed.
//    - progress (optional): callback.
//
func (self *Installation) Uninstall(ctx context.Context, kind RefKind, name, arch, branch string, progress ProgressCallback) error {
	var _arg0 *C.FlatpakInstallation    // out
	var _arg7 *C.GCancellable           // out
	var _arg1 C.FlatpakRefKind          // out
	var _arg2 *C.char                   // out
	var _arg3 *C.char                   // out
	var _arg4 *C.char                   // out
	var _arg5 C.FlatpakProgressCallback // out
	var _arg6 C.gpointer
	var _cerr *C.GError // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg7 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.FlatpakRefKind(kind)
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg2))
	if arch != "" {
		_arg3 = (*C.char)(unsafe.Pointer(C.CString(arch)))
		defer C.free(unsafe.Pointer(_arg3))
	}
	if branch != "" {
		_arg4 = (*C.char)(unsafe.Pointer(C.CString(branch)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if progress != nil {
		_arg5 = (*[0]byte)(C._gotk4_flatpak1_ProgressCallback)
		_arg6 = C.gpointer(gbox.Assign(progress))
		defer gbox.Delete(uintptr(_arg6))
	}

	C.flatpak_installation_uninstall(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(kind)
	runtime.KeepAlive(name)
	runtime.KeepAlive(arch)
	runtime.KeepAlive(branch)
	runtime.KeepAlive(progress)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// UninstallFull: this is an old deprecated function, you should use Transaction
// and flatpak_transaction_add_uninstall() instead. It has a lot more
// interesting features.
//
// Uninstall an application or runtime.
//
// Deprecated: Use flatpak_transaction_add_uninstall() instead.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - flags: set of UninstallFlags flags.
//    - kind: what this ref contains (an RefKind).
//    - name of the app or runtime to uninstall.
//    - arch (optional): architecture of the app or runtime to uninstall; if
//      NULL, flatpak_get_default_arch() is assumed.
//    - branch (optional): name of the branch of the app or runtime to uninstall;
//      if NULL, master is assumed.
//    - progress (optional): callback.
//
func (self *Installation) UninstallFull(ctx context.Context, flags UninstallFlags, kind RefKind, name, arch, branch string, progress ProgressCallback) error {
	var _arg0 *C.FlatpakInstallation    // out
	var _arg8 *C.GCancellable           // out
	var _arg1 C.FlatpakUninstallFlags   // out
	var _arg2 C.FlatpakRefKind          // out
	var _arg3 *C.char                   // out
	var _arg4 *C.char                   // out
	var _arg5 *C.char                   // out
	var _arg6 C.FlatpakProgressCallback // out
	var _arg7 C.gpointer
	var _cerr *C.GError // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg8 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.FlatpakUninstallFlags(flags)
	_arg2 = C.FlatpakRefKind(kind)
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))
	if arch != "" {
		_arg4 = (*C.char)(unsafe.Pointer(C.CString(arch)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if branch != "" {
		_arg5 = (*C.char)(unsafe.Pointer(C.CString(branch)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if progress != nil {
		_arg6 = (*[0]byte)(C._gotk4_flatpak1_ProgressCallback)
		_arg7 = C.gpointer(gbox.Assign(progress))
		defer gbox.Delete(uintptr(_arg7))
	}

	C.flatpak_installation_uninstall_full(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(kind)
	runtime.KeepAlive(name)
	runtime.KeepAlive(arch)
	runtime.KeepAlive(branch)
	runtime.KeepAlive(progress)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Update: this is an old deprecated function, you should use Transaction and
// flatpak_transaction_add_update() instead. It has a lot more interesting
// features.
//
// Update an application or runtime.
//
// If the specified package is not installed, then FLATPAK_ERROR_NOT_INSTALLED
// will be thrown.
//
// If no updates could be found on the remote end and the package is already up
// to date, then FLATPAK_ERROR_ALREADY_INSTALLED will be thrown.
//
// Deprecated: Use flatpak_transaction_add_update() instead.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - flags: set of UpdateFlags flag.
//    - kind: whether this is an app or runtime.
//    - name of the app or runtime to update.
//    - arch (optional): architecture of the app or runtime to update (default:
//      current architecture).
//    - branch (optional): name of the branch of the app or runtime to update
//      (default: master).
//    - progress (optional): callback.
//
// The function returns the following values:
//
//    - installedRef: ref for the newly updated app or NULL on failure.
//
func (self *Installation) Update(ctx context.Context, flags UpdateFlags, kind RefKind, name, arch, branch string, progress ProgressCallback) (*InstalledRef, error) {
	var _arg0 *C.FlatpakInstallation    // out
	var _arg8 *C.GCancellable           // out
	var _arg1 C.FlatpakUpdateFlags      // out
	var _arg2 C.FlatpakRefKind          // out
	var _arg3 *C.char                   // out
	var _arg4 *C.char                   // out
	var _arg5 *C.char                   // out
	var _arg6 C.FlatpakProgressCallback // out
	var _arg7 C.gpointer
	var _cret *C.FlatpakInstalledRef // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg8 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.FlatpakUpdateFlags(flags)
	_arg2 = C.FlatpakRefKind(kind)
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))
	if arch != "" {
		_arg4 = (*C.char)(unsafe.Pointer(C.CString(arch)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if branch != "" {
		_arg5 = (*C.char)(unsafe.Pointer(C.CString(branch)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	if progress != nil {
		_arg6 = (*[0]byte)(C._gotk4_flatpak1_ProgressCallback)
		_arg7 = C.gpointer(gbox.Assign(progress))
		defer gbox.Delete(uintptr(_arg7))
	}

	_cret = C.flatpak_installation_update(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(kind)
	runtime.KeepAlive(name)
	runtime.KeepAlive(arch)
	runtime.KeepAlive(branch)
	runtime.KeepAlive(progress)

	var _installedRef *InstalledRef // out
	var _goerr error                // out

	_installedRef = wrapInstalledRef(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _installedRef, _goerr
}

// UpdateFull: this is an old deprecated function, you should use Transaction
// and flatpak_transaction_add_update() instead. It has a lot more interesting
// features.
//
// Update an application or runtime.
//
// If the specified package is not installed, then FLATPAK_ERROR_NOT_INSTALLED
// will be thrown.
//
// If no updates could be found on the remote end and the package is already up
// to date, then FLATPAK_ERROR_ALREADY_INSTALLED will be thrown.
//
// Deprecated: Use flatpak_transaction_add_update() instead.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - flags: set of UpdateFlags flag.
//    - kind: whether this is an app or runtime.
//    - name of the app or runtime to update.
//    - arch (optional): architecture of the app or runtime to update (default:
//      current architecture).
//    - branch (optional): name of the branch of the app or runtime to update
//      (default: master).
//    - subpaths (optional): list of subpaths to fetch, or NULL for everything.
//    - progress (optional): callback.
//
// The function returns the following values:
//
//    - installedRef: ref for the newly updated app or NULL on failure.
//
func (self *Installation) UpdateFull(ctx context.Context, flags UpdateFlags, kind RefKind, name, arch, branch string, subpaths []string, progress ProgressCallback) (*InstalledRef, error) {
	var _arg0 *C.FlatpakInstallation    // out
	var _arg9 *C.GCancellable           // out
	var _arg1 C.FlatpakUpdateFlags      // out
	var _arg2 C.FlatpakRefKind          // out
	var _arg3 *C.char                   // out
	var _arg4 *C.char                   // out
	var _arg5 *C.char                   // out
	var _arg6 **C.char                  // out
	var _arg7 C.FlatpakProgressCallback // out
	var _arg8 C.gpointer
	var _cret *C.FlatpakInstalledRef // in
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg9 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.FlatpakUpdateFlags(flags)
	_arg2 = C.FlatpakRefKind(kind)
	_arg3 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg3))
	if arch != "" {
		_arg4 = (*C.char)(unsafe.Pointer(C.CString(arch)))
		defer C.free(unsafe.Pointer(_arg4))
	}
	if branch != "" {
		_arg5 = (*C.char)(unsafe.Pointer(C.CString(branch)))
		defer C.free(unsafe.Pointer(_arg5))
	}
	{
		_arg6 = (**C.char)(C.calloc(C.size_t((len(subpaths) + 1)), C.size_t(unsafe.Sizeof(uint(0)))))
		defer C.free(unsafe.Pointer(_arg6))
		{
			out := unsafe.Slice(_arg6, len(subpaths)+1)
			var zero *C.char
			out[len(subpaths)] = zero
			for i := range subpaths {
				out[i] = (*C.char)(unsafe.Pointer(C.CString(subpaths[i])))
				defer C.free(unsafe.Pointer(out[i]))
			}
		}
	}
	if progress != nil {
		_arg7 = (*[0]byte)(C._gotk4_flatpak1_ProgressCallback)
		_arg8 = C.gpointer(gbox.Assign(progress))
		defer gbox.Delete(uintptr(_arg8))
	}

	_cret = C.flatpak_installation_update_full(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)
	runtime.KeepAlive(kind)
	runtime.KeepAlive(name)
	runtime.KeepAlive(arch)
	runtime.KeepAlive(branch)
	runtime.KeepAlive(subpaths)
	runtime.KeepAlive(progress)

	var _installedRef *InstalledRef // out
	var _goerr error                // out

	_installedRef = wrapInstalledRef(externglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _installedRef, _goerr
}

// UpdateRemoteSync updates the local configuration of a remote repository by
// fetching the related information from the summary file in the remote OSTree
// repository and committing the changes to the local installation.
//
// The function takes the following parameters:
//
//    - ctx (optional): #GCancellable.
//    - name of the remote to update.
//
func (self *Installation) UpdateRemoteSync(ctx context.Context, name string) error {
	var _arg0 *C.FlatpakInstallation // out
	var _arg2 *C.GCancellable        // out
	var _arg1 *C.char                // out
	var _cerr *C.GError              // in

	_arg0 = (*C.FlatpakInstallation)(unsafe.Pointer(externglib.InternObject(self).Native()))
	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(name)))
	defer C.free(unsafe.Pointer(_arg1))

	C.flatpak_installation_update_remote_sync(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(self)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(name)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}
